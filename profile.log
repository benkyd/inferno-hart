SCRIPT  /usr/share/nvim/runtime/ftplugin.vim
Sourced 1 time
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
                            " Vim support file to switch on loading plugins for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2006 Apr 30
                            
    1              0.000018 if exists("did_load_ftplugin")
                              finish
    1              0.000001 endif
    1              0.000006 let did_load_ftplugin = 1
                            
    1              0.000019 augroup filetypeplugin
    1              0.000009   au FileType * call s:LoadFTPlugin()
                            
    1              0.000007   func! s:LoadFTPlugin()
                                if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
                                let s = expand("<amatch>")
                                if s != ""
                                  if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
                                  for name in split(s, '\.')
                                    exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                    " Load lua ftplugins
                                    exe printf('runtime! ftplugin/%s.lua ftplugin/%s_*.lua ftplugin/%s/*.lua', name, name, name)
                                  endfor
                                endif
                              endfunc
    1              0.000002 augroup END

SCRIPT  /usr/share/nvim/runtime/indent.vim
Sourced 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
                            " Vim support file to switch on loading indent files for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2008 Feb 22
                            
    1              0.000004 if exists("did_indent_on")
                              finish
    1              0.000001 endif
    1              0.000003 let did_indent_on = 1
                            
    1              0.000003 augroup filetypeindent
    1              0.000004   au FileType * call s:LoadIndent()
    1              0.000002   func! s:LoadIndent()
                                if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
                                let s = expand("<amatch>")
                                if s != ""
                                  if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
                                  for name in split(s, '\.')
                                    exe 'runtime! indent/' . name . '.vim'
                                    exe 'runtime! indent/' . name . '.lua'
                                  endfor
                                endif
                              endfunc
    1              0.000001 augroup END

SCRIPT  /etc/xdg/nvim/sysinit.vim
Sourced 1 time
Total time:   0.000041
 Self time:   0.000022

count  total (s)   self (s)
                            " This line makes pacman-installed global Arch Linux vim packages work.
    1   0.000038   0.000019 source /usr/share/nvim/archlinux.vim

SCRIPT  /usr/share/nvim/archlinux.vim
Sourced 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000010 set runtimepath+=/usr/share/vim/vimfiles

SCRIPT  /home/benk/.config/nvim/init.lua
Sourced 1 time
Total time:   0.130214
 Self time:   0.130214

count  total (s)   self (s)
                            require('basics')
                            require('globals')
                            require('keymappings')
                            require('plugins')
                            require('lsp-general')
                            require('post-plugin-basics')
                            

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/kanagawa.nvim/colors/kanagawa.vim
Sourced 1 time
Total time:   0.003478
 Self time:   0.003478

count  total (s)   self (s)
    1              0.003471 lua require('kanagawa').load()

SCRIPT  /usr/share/nvim/runtime/filetype.lua
Sourced 1 time
Total time:   0.000978
 Self time:   0.000978

count  total (s)   self (s)
                            -- Skip if legacy filetype is enabled or filetype detection is disabled
                            if vim.g.do_legacy_filetype or vim.g.did_load_filetypes then
                              return
                            end
                            vim.g.did_load_filetypes = 1
                            
                            vim.api.nvim_create_augroup('filetypedetect', { clear = false })
                            
                            vim.api.nvim_create_autocmd({ 'BufRead', 'BufNewFile', 'StdinReadPost' }, {
                              group = 'filetypedetect',
                              callback = function(args)
                                local ft, on_detect = vim.filetype.match({ filename = args.match, buf = args.buf })
                                if not ft then
                                  -- Generic configuration file used as fallback
                                  ft = require('vim.filetype.detect').conf(args.file, args.buf)
                                  if ft then
                                    vim.api.nvim_buf_call(args.buf, function()
                                      vim.api.nvim_cmd({ cmd = 'setf', args = { 'FALLBACK', ft } }, {})
                                    end)
                                  end
                                else
                                  vim.api.nvim_buf_call(args.buf, function()
                                    vim.api.nvim_cmd({ cmd = 'setf', args = { ft } }, {})
                                  end)
                                  if on_detect then
                                    on_detect(args.buf)
                                  end
                                end
                              end,
                            })
                            
                            -- These *must* be sourced after the autocommand above is created
                            if not vim.g.did_load_ftdetect then
                              vim.cmd([[
                              augroup filetypedetect
                              runtime! ftdetect/*.vim
                              runtime! ftdetect/*.lua
                              augroup END
                              ]])
                            end
                            
                            -- Set up the autocmd for user scripts.vim
                            vim.api.nvim_create_autocmd({ 'BufRead', 'BufNewFile' }, {
                              group = 'filetypedetect',
                              command = "if !did_filetype() && expand('<amatch>') !~ g:ft_ignore_pat | runtime! scripts.vim | endif",
                            })
                            
                            vim.api.nvim_create_autocmd('StdinReadPost', {
                              group = 'filetypedetect',
                              command = 'if !did_filetype() | runtime! scripts.vim | endif',
                            })
                            
                            if not vim.g.ft_ignore_pat then
                              vim.g.ft_ignore_pat = '\\.\\(Z\\|gz\\|bz2\\|zip\\|tgz\\)$'
                            end

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/vim-fugitive/ftdetect/fugitive.vim
Sourced 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000009 autocmd BufReadPost *.fugitiveblame setfiletype fugitiveblame

SCRIPT  /usr/share/vim/vimfiles/ftdetect/PKGBUILD.vim
Sourced 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000009 au BufNewFile,BufRead PKGBUILD set filetype=PKGBUILD

SCRIPT  /usr/share/vim/vimfiles/ftdetect/SRCINFO.vim
Sourced 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000008 au BufNewFile,BufRead .SRCINFO set filetype=SRCINFO

SCRIPT  /usr/share/vim/vimfiles/ftdetect/conkyrc.vim
Sourced 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
                            " Vim filetype detection file for Conky config files
                            "
                            
    1              0.000007 au BufNewFile,BufRead *conkyrc set filetype=conkyrc
    1              0.000007 au BufNewFile,BufRead conky.conf set filetype=conkyrc

SCRIPT  /usr/share/vim/vimfiles/ftdetect/meson.vim
Sourced 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000007 au BufNewFile,BufRead meson.build set filetype=meson
    1              0.000009 au BufNewFile,BufRead meson_options.txt set filetype=meson
    1              0.000006 au BufNewFile,BufRead *.wrap set filetype=dosini

SCRIPT  /usr/share/nvim/runtime/filetype.vim
Sourced 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
                            " Vim support file to detect file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2022 Sep 27
                            
                            " Only run this if enabled
    1              0.000012 if !exists("do_legacy_filetype")
    1              0.000003   finish
                            endif
                            
                            " Listen very carefully, I will say this only once
                            if exists("did_load_filetypes")
                              finish
                            endif
                            let did_load_filetypes = 1
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            augroup filetypedetect
                            
                            " Ignored extensions
                            if exists("*fnameescape")
                            au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew
                            	\ exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
                            au BufNewFile,BufRead *~
                            	\ let s:name = expand("<afile>") |
                            	\ let s:short = substitute(s:name, '\~$', '', '') |
                            	\ if s:name != s:short && s:short != "" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(s:short) |
                            	\ endif |
                            	\ unlet! s:name s:short
                            au BufNewFile,BufRead ?\+.in
                            	\ if expand("<afile>:t") != "configure.in" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) |
                            	\ endif
                            elseif &verbose > 0
                              echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
                            endif
                            
                            " Pattern used to match file names which should not be inspected.
                            " Currently finds compressed files.
                            if !exists("g:ft_ignore_pat")
                              let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
                            endif
                            
                            " Function used for patterns that end in a star: don't set the filetype if the
                            " file name matches ft_ignore_pat.
                            " When using this, the entry should probably be further down below with the
                            " other StarSetf() calls.
                            func s:StarSetf(ft)
                              if expand("<amatch>") !~ g:ft_ignore_pat
                                exe 'setf ' . a:ft
                              endif
                            endfunc
                            
                            " Vim help file
                            au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt setf help
                            
                            " Abaqus or Trasys
                            au BufNewFile,BufRead *.inp			call dist#ft#Check_inp()
                            
                            " 8th (Firth-derivative)
                            au BufNewFile,BufRead *.8th			setf 8th
                            
                            " A-A-P recipe
                            au BufNewFile,BufRead *.aap			setf aap
                            
                            " A2ps printing utility
                            au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
                            
                            " ABAB/4
                            au BufNewFile,BufRead *.abap			setf abap
                            
                            " ABC music notation
                            au BufNewFile,BufRead *.abc			setf abc
                            
                            " ABEL
                            au BufNewFile,BufRead *.abl			setf abel
                            
                            " AceDB
                            au BufNewFile,BufRead *.wrm			setf acedb
                            
                            " Ada (83, 9X, 95)
                            au BufNewFile,BufRead *.adb,*.ads,*.ada		setf ada
                            au BufNewFile,BufRead *.gpr			setf ada
                            
                            " AHDL
                            au BufNewFile,BufRead *.tdf			setf ahdl
                            
                            " AIDL
                            au BufNewFile,BufRead *.aidl			setf aidl
                            
                            " AMPL
                            au BufNewFile,BufRead *.run			setf ampl
                            
                            " Ant
                            au BufNewFile,BufRead build.xml			setf ant
                            
                            " Arduino
                            au BufNewFile,BufRead *.ino,*.pde		setf arduino
                            
                            " Apache config file
                            au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf		setf apache
                            au BufNewFile,BufRead */etc/apache2/sites-*/*.com		setf apache
                            
                            " XA65 MOS6510 cross assembler
                            au BufNewFile,BufRead *.a65			setf a65
                            
                            " Applescript
                            au BufNewFile,BufRead *.scpt			setf applescript
                            
                            " Applix ELF
                            au BufNewFile,BufRead *.am
                            	\ if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
                            
                            " ALSA configuration
                            au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
                            
                            " Arc Macro Language
                            au BufNewFile,BufRead *.aml			setf aml
                            
                            " APT config file
                            au BufNewFile,BufRead apt.conf		       setf aptconf
                            au BufNewFile,BufRead */.aptitude/config       setf aptconf
                            " more generic pattern far down
                            
                            " Arch Inventory file
                            au BufNewFile,BufRead .arch-inventory,=tagging-method	setf arch
                            
                            " ART*Enterprise (formerly ART-IM)
                            au BufNewFile,BufRead *.art			setf art
                            
                            " AsciiDoc
                            au BufNewFile,BufRead *.asciidoc,*.adoc		setf asciidoc
                            
                            " ASN.1
                            au BufNewFile,BufRead *.asn,*.asn1		setf asn
                            
                            " Active Server Pages (with Visual Basic Script)
                            au BufNewFile,BufRead *.asa
                            	\ if exists("g:filetype_asa") |
                            	\   exe "setf " . g:filetype_asa |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Active Server Pages (with Perl or Visual Basic Script)
                            au BufNewFile,BufRead *.asp
                            	\ if exists("g:filetype_asp") |
                            	\   exe "setf " . g:filetype_asp |
                            	\ elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |
                            	\   setf aspperl |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Grub (must be before pattern *.lst)
                            au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
                            
                            " Maxima, see:
                            " https://maxima.sourceforge.io/docs/manual/maxima_71.html#file_005ftype_005fmaxima
                            " Must be before the pattern *.mac.
                            " *.dem omitted - also used by gnuplot demos
                            " *.mc omitted - used by dist#ft#McSetf()
                            au BufNewFile,BufRead *.demo,*.dm{1,2,3,t},*.wxm,maxima-init.mac setf maxima
                            
                            " Assembly (all kinds)
                            " *.lst is not pure assembly, it has two extra columns (address, byte codes)
                            au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst	call dist#ft#FTasm()
                            
                            " Assembly - Macro (VAX)
                            au BufNewFile,BufRead *.mar			setf vmasm
                            
                            " Astro
                            au BufNewFile,BufRead *.astro			setf astro
                            
                            " Atlas
                            au BufNewFile,BufRead *.atl,*.as		setf atlas
                            
                            " Atom is based on XML
                            au BufNewFile,BufRead *.atom			setf xml
                            
                            " Autoit v3
                            au BufNewFile,BufRead *.au3			setf autoit
                            
                            " Autohotkey
                            au BufNewFile,BufRead *.ahk			setf autohotkey
                            
                            " Automake
                            au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am	setf automake
                            
                            " Autotest .at files are actually m4
                            au BufNewFile,BufRead *.at			setf m4
                            
                            " Avenue
                            au BufNewFile,BufRead *.ave			setf ave
                            
                            " Awk
                            au BufNewFile,BufRead *.awk,*.gawk		setf awk
                            
                            " B
                            au BufNewFile,BufRead *.mch,*.ref,*.imp		setf b
                            
                            " BASIC or Visual Basic
                            au BufNewFile,BufRead *.bas			call dist#ft#FTbas()
                            au BufNewFile,BufRead *.bi,*.bm			call dist#ft#FTbas()
                            
                            " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
                            au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl	setf vb
                            
                            " IBasic file (similar to QBasic)
                            au BufNewFile,BufRead *.iba,*.ibi		setf ibasic
                            
                            " FreeBasic file (similar to QBasic)
                            au BufNewFile,BufRead *.fb			setf freebasic
                            
                            " Batch file for MSDOS. See dist#ft#FTsys for *.sys
                            au BufNewFile,BufRead *.bat			setf dosbatch
                            " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
                            au BufNewFile,BufRead *.cmd
                            	\ if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
                            " ABB RAPID or Batch file for MSDOS.
                            au BufNewFile,BufRead *.sys\c			call dist#ft#FTsys()
                            
                            " Batch file for 4DOS
                            au BufNewFile,BufRead *.btm			call dist#ft#FTbtm()
                            
                            " BC calculator
                            au BufNewFile,BufRead *.bc			setf bc
                            
                            " BDF font
                            au BufNewFile,BufRead *.bdf			setf bdf
                            
                            " Beancount
                            au BufNewFile,BufRead *.beancount		setf beancount
                            
                            " BibTeX bibliography database file
                            au BufNewFile,BufRead *.bib			setf bib
                            
                            " BibTeX Bibliography Style
                            au BufNewFile,BufRead *.bst			setf bst
                            
                            " Bicep
                            au BufNewFile,BufRead *.bicep			setf bicep
                            
                            " BIND configuration
                            " sudoedit uses namedXXXX.conf
                            au BufNewFile,BufRead named*.conf,rndc*.conf,rndc*.key	setf named
                            
                            " BIND zone
                            au BufNewFile,BufRead named.root		setf bindzone
                            au BufNewFile,BufRead *.db			call dist#ft#BindzoneCheck('')
                            
                            " Blank
                            au BufNewFile,BufRead *.bl			setf blank
                            
                            " Bitbake
                            au BufNewFile,BufRead *.bb,*.bbappend,*.bbclass,*/build/conf/*.conf,*/meta{-*,}/conf/*.conf	setf bitbake
                            
                            " Blkid cache file
                            au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
                            
                            " BSDL
                            au BufNewFile,BufRead *.bsd,*.bsdl			setf bsdl
                            
                            " Bazel (http://bazel.io)
                            autocmd BufRead,BufNewFile *.bzl,*.bazel,WORKSPACE	setf bzl
                            if has("fname_case")
                              " There is another check for BUILD further below.
                              autocmd BufRead,BufNewFile *.BUILD,BUILD		setf bzl
                            endif
                            
                            " C or lpc
                            au BufNewFile,BufRead *.c			call dist#ft#FTlpc()
                            au BufNewFile,BufRead *.lpc,*.ulpc		setf lpc
                            
                            " Calendar
                            au BufNewFile,BufRead calendar			setf calendar
                            
                            " C#
                            au BufNewFile,BufRead *.cs,*.csx		setf cs
                            
                            " CSDL
                            au BufNewFile,BufRead *.csdl			setf csdl
                            
                            " Cabal
                            au BufNewFile,BufRead *.cabal			setf cabal
                            
                            " Cdrdao TOC
                            au BufNewFile,BufRead *.toc			setf cdrtoc
                            
                            " Cdrdao config
                            au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao	setf cdrdaoconf
                            
                            " Cfengine
                            au BufNewFile,BufRead cfengine.conf		setf cfengine
                            
                            " ChaiScript
                            au BufRead,BufNewFile *.chai			setf chaiscript
                            
                            " Chatito
                            au BufNewFile,BufRead *.chatito			setf chatito
                            
                            " Comshare Dimension Definition Language
                            au BufNewFile,BufRead *.cdl			setf cdl
                            
                            " Conary Recipe
                            au BufNewFile,BufRead *.recipe			setf conaryrecipe
                            
                            " Controllable Regex Mutilator
                            au BufNewFile,BufRead *.crm			setf crm
                            
                            " Cyn++
                            au BufNewFile,BufRead *.cyn			setf cynpp
                            
                            " Cynlib
                            " .cc and .cpp files can be C++ or Cynlib.
                            au BufNewFile,BufRead *.cc
                            	\ if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
                            au BufNewFile,BufRead *.cpp
                            	\ if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
                            
                            " C++
                            au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
                            if has("fname_case")
                              au BufNewFile,BufRead *.C,*.H setf cpp
                            endif
                            
                            " .h files can be C, Ch C++, ObjC or ObjC++.
                            " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
                            " detected automatically.
                            au BufNewFile,BufRead *.h			call dist#ft#FTheader()
                            
                            " Ch (CHscript)
                            au BufNewFile,BufRead *.chf			setf ch
                            
                            " TLH files are C++ headers generated by Visual C++'s #import from typelibs
                            au BufNewFile,BufRead *.tlh			setf cpp
                            
                            " Cascading Style Sheets
                            au BufNewFile,BufRead *.css			setf css
                            
                            " Century Term Command Scripts (*.cmd too)
                            au BufNewFile,BufRead *.con			setf cterm
                            
                            " Changelog
                            au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch,*/debian/changelog
                            					\	setf debchangelog
                            
                            au BufNewFile,BufRead [cC]hange[lL]og
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| else
                            	\|   setf changelog
                            	\| endif
                            
                            au BufNewFile,BufRead NEWS
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| endif
                            
                            " CHILL
                            au BufNewFile,BufRead *..ch			setf chill
                            
                            " Changes for WEB and CWEB or CHILL
                            au BufNewFile,BufRead *.ch			call dist#ft#FTchange()
                            
                            " ChordPro
                            au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro	setf chordpro
                            
                            " Clean
                            au BufNewFile,BufRead *.dcl,*.icl		setf clean
                            
                            " Clever
                            au BufNewFile,BufRead *.eni			setf cl
                            
                            " Clever or dtd
                            au BufNewFile,BufRead *.ent			call dist#ft#FTent()
                            
                            " Clipper, FoxPro, ABB RAPID or eviews
                            au BufNewFile,BufRead *.prg\c			call dist#ft#FTprg()
                            
                            " Clojure
                            au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc		setf clojure
                            
                            " Cmake
                            au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in		setf cmake
                            
                            " Cmusrc
                            au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
                            au BufNewFile,BufRead */cmus/{rc,*.theme}			setf cmusrc
                            
                            " Cobol
                            au BufNewFile,BufRead *.cbl,*.cob,*.lib	setf cobol
                            "   cobol or zope form controller python script? (heuristic)
                            au BufNewFile,BufRead *.cpy
                            	\ if getline(1) =~ '^##' |
                            	\   setf python |
                            	\ else |
                            	\   setf cobol |
                            	\ endif
                            
                            " Coco/R
                            au BufNewFile,BufRead *.atg			setf coco
                            
                            " Cold Fusion
                            au BufNewFile,BufRead *.cfm,*.cfi,*.cfc		setf cf
                            
                            " Configure scripts
                            au BufNewFile,BufRead configure.in,configure.ac setf config
                            
                            " Cooklang
                            au BufNewFile,BufRead *.cook			setf cook
                            
                            " CSV Files
                            au BufNewFile,BufRead *.csv			setf csv
                            
                            " CUDA Compute Unified Device Architecture
                            au BufNewFile,BufRead *.cu,*.cuh		setf cuda
                            
                            " Dockerfile; Podman uses the same syntax with name Containerfile
                            " Also see Dockerfile.* below.
                            au BufNewFile,BufRead Containerfile,Dockerfile,dockerfile,*.[dD]ockerfile	setf dockerfile
                            
                            " WildPackets EtherPeek Decoder
                            au BufNewFile,BufRead *.dcd			setf dcd
                            
                            " Enlightenment configuration files
                            au BufNewFile,BufRead *enlightenment/*.cfg	setf c
                            
                            " Eterm
                            au BufNewFile,BufRead *Eterm/*.cfg		setf eterm
                            
                            " Elixir or Euphoria
                            au BufNewFile,BufRead *.ex call dist#ft#ExCheck()
                            
                            " Elixir
                            au BufRead,BufNewFile mix.lock,*.exs setf elixir
                            au BufRead,BufNewFile *.eex,*.leex setf eelixir
                            
                            " Elvish
                            au BufRead,BufNewFile *.elv setf elvish
                            
                            " Euphoria 3 or 4
                            au BufNewFile,BufRead *.eu,*.ew,*.exu,*.exw  call dist#ft#EuphoriaCheck()
                            if has("fname_case")
                               au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call dist#ft#EuphoriaCheck()
                            endif
                            
                            " Lynx config files
                            au BufNewFile,BufRead lynx.cfg			setf lynx
                            
                            " LyRiCs
                            au BufNewFile,BufRead *.lrc			setf lyrics
                            
                            " Modula-3 configuration language (must be before *.cfg and *makefile)
                            au BufNewFile,BufRead *.quake,cm3.cfg		setf m3quake
                            au BufNewFile,BufRead m3makefile,m3overrides	setf m3build
                            
                            " Quake
                            au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg	setf quake
                            au BufNewFile,BufRead *quake[1-3]/*.cfg			setf quake
                            
                            " Quake C
                            au BufNewFile,BufRead *.qc			setf c
                            
                            " Configure files
                            au BufNewFile,BufRead *.cfg\c			call dist#ft#FTcfg()
                            
                            " Cucumber
                            au BufNewFile,BufRead *.feature			setf cucumber
                            
                            " Communicating Sequential Processes
                            au BufNewFile,BufRead *.csp,*.fdr		setf csp
                            
                            " CUPL logic description and simulation
                            au BufNewFile,BufRead *.pld			setf cupl
                            au BufNewFile,BufRead *.si			setf cuplsim
                            
                            " Dart
                            au BufRead,BufNewfile *.dart,*.drt		setf dart
                            
                            " Debian Control
                            au BufNewFile,BufRead */debian/control		setf debcontrol
                            au BufNewFile,BufRead control
                            	\  if getline(1) =~ '^Source:'
                            	\|   setf debcontrol
                            	\| endif
                            
                            " Debian Copyright
                            au BufNewFile,BufRead */debian/copyright	setf debcopyright
                            au BufNewFile,BufRead copyright
                            	\  if getline(1) =~ '^Format:'
                            	\|   setf debcopyright
                            	\| endif
                            
                            " Debian Sources.list
                            au BufNewFile,BufRead */etc/apt/sources.list		setf debsources
                            au BufNewFile,BufRead */etc/apt/sources.list.d/*.list	setf debsources
                            
                            " Deny hosts
                            au BufNewFile,BufRead denyhosts.conf		setf denyhosts
                            
                            " dnsmasq(8) configuration files
                            au BufNewFile,BufRead */etc/dnsmasq.conf	setf dnsmasq
                            
                            " ROCKLinux package description
                            au BufNewFile,BufRead *.desc			setf desc
                            
                            " the D language or dtrace
                            au BufNewFile,BufRead */dtrace/*.d		setf dtrace
                            au BufNewFile,BufRead *.d			call dist#ft#DtraceCheck()
                            
                            " Desktop files
                            au BufNewFile,BufRead *.desktop,*.directory	setf desktop
                            
                            " Dict config
                            au BufNewFile,BufRead dict.conf,.dictrc		setf dictconf
                            
                            " Dictd config
                            au BufNewFile,BufRead dictd*.conf		setf dictdconf
                            
                            " DEP3 formatted patch files
                            au BufNewFile,BufRead */debian/patches/*	call dist#ft#Dep3patch()
                            
                            " Diff files
                            au BufNewFile,BufRead *.diff,*.rej		setf diff
                            au BufNewFile,BufRead *.patch
                            	\ if getline(1) =~# '^From [0-9a-f]\{40,\} Mon Sep 17 00:00:00 2001$' |
                            	\   setf gitsendemail |
                            	\ else |
                            	\   setf diff |
                            	\ endif
                            
                            " Dircolors
                            au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS	setf dircolors
                            
                            " Diva (with Skill) or InstallShield
                            au BufNewFile,BufRead *.rul
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |
                            	\   setf ishd |
                            	\ else |
                            	\   setf diva |
                            	\ endif
                            
                            " DCL (Digital Command Language - vms) or DNS zone file
                            au BufNewFile,BufRead *.com			call dist#ft#BindzoneCheck('dcl')
                            
                            " DOT
                            au BufNewFile,BufRead *.dot,*.gv		setf dot
                            
                            " Dune
                            au BufNewFile,BufRead jbuild,dune,dune-project,dune-workspace setf dune
                            
                            " Dylan - lid files
                            au BufNewFile,BufRead *.lid			setf dylanlid
                            
                            " Dylan - intr files (melange)
                            au BufNewFile,BufRead *.intr			setf dylanintr
                            
                            " Dylan
                            au BufNewFile,BufRead *.dylan			setf dylan
                            
                            " Microsoft Module Definition
                            au BufNewFile,BufRead *.def			setf def
                            
                            " Dracula
                            au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe	setf dracula
                            
                            " Datascript
                            au BufNewFile,BufRead *.ds			setf datascript
                            
                            " dsl: DSSSL or Structurizr
                            au BufNewFile,BufRead *.dsl
                            	\ if getline(1) =~ '^\s*<\!' |
                            	\   setf dsl |
                            	\ else |
                            	\   setf structurizr |
                            	\ endif
                            
                            " DTD (Document Type Definition for XML)
                            au BufNewFile,BufRead *.dtd			setf dtd
                            
                            " DTS/DSTI (device tree files)
                            au BufNewFile,BufRead *.dts,*.dtsi		setf dts
                            
                            " EDIF (*.edf,*.edif,*.edn,*.edo) or edn
                            au BufNewFile,BufRead *.ed\(f\|if\|o\)		setf edif
                            au BufNewFile,BufRead *.edn
                            	\ if getline(1) =~ '^\s*(\s*edif\>' |
                            	\   setf edif |
                            	\ else |
                            	\   setf clojure |
                            	\ endif
                            
                            " EditorConfig (close enough to dosini)
                            au BufNewFile,BufRead .editorconfig		setf dosini
                            
                            " Embedix Component Description
                            au BufNewFile,BufRead *.ecd			setf ecd
                            
                            " Eiffel or Specman or Euphoria
                            au BufNewFile,BufRead *.e,*.E			call dist#ft#FTe()
                            
                            " Elinks configuration
                            au BufNewFile,BufRead elinks.conf		setf elinks
                            
                            " ERicsson LANGuage; Yaws is erlang too
                            au BufNewFile,BufRead *.erl,*.hrl,*.yaws	setf erlang
                            
                            " Elm
                            au BufNewFile,BufRead *.elm			setf elm
                            
                            " Elm Filter Rules file
                            au BufNewFile,BufRead filter-rules		setf elmfilt
                            
                            " ESMTP rc file
                            au BufNewFile,BufRead *esmtprc			setf esmtprc
                            
                            " ESQL-C
                            au BufNewFile,BufRead *.ec,*.EC			setf esqlc
                            
                            " Esterel
                            au BufNewFile,BufRead *.strl			setf esterel
                            
                            " Essbase script
                            au BufNewFile,BufRead *.csc			setf csc
                            
                            " Exim
                            au BufNewFile,BufRead exim.conf			setf exim
                            
                            " Expect
                            au BufNewFile,BufRead *.exp			setf expect
                            
                            " Exports
                            au BufNewFile,BufRead exports			setf exports
                            
                            " Falcon
                            au BufNewFile,BufRead *.fal			setf falcon
                            
                            " Fantom
                            au BufNewFile,BufRead *.fan,*.fwt		setf fan
                            
                            " Factor
                            au BufNewFile,BufRead *.factor			setf factor
                            
                            " Fennel
                            autocmd BufRead,BufNewFile *.fnl		setf fennel
                            
                            " Fetchmail RC file
                            au BufNewFile,BufRead .fetchmailrc		setf fetchmail
                            
                            " Fish shell
                            au BufNewFile,BufRead *.fish			setf fish
                            
                            " FlexWiki - disabled, because it has side effects when a .wiki file
                            " is not actually FlexWiki
                            "au BufNewFile,BufRead *.wiki			setf flexwiki
                            
                            " Focus Executable
                            au BufNewFile,BufRead *.fex,*.focexec		setf focexec
                            
                            " Focus Master file (but not for auto.master)
                            au BufNewFile,BufRead auto.master		setf conf
                            au BufNewFile,BufRead *.mas,*.master		setf master
                            
                            " Forth
                            au BufNewFile,BufRead *.ft,*.fth		setf forth
                            
                            " Reva Forth
                            au BufNewFile,BufRead *.frt			setf reva
                            
                            " Fortran
                            if has("fname_case")
                              au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08	 setf fortran
                            endif
                            au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
                            
                            " Framescript
                            au BufNewFile,BufRead *.fsl			setf framescript
                            
                            " FStab
                            au BufNewFile,BufRead fstab,mtab		setf fstab
                            
                            " Fusion
                            au BufRead,BufNewFile *.fusion			setf fusion
                            
                            " F# or Forth
                            au BufNewFile,BufRead *.fs			call dist#ft#FTfs()
                            
                            " F#
                            au BufNewFile,BufRead *.fsi,*.fsx		setf fsharp
                            
                            " GDB command files
                            au BufNewFile,BufRead .gdbinit,gdbinit,.gdbearlyinit,gdbearlyinit,*.gdb		setf gdb
                            
                            " GDMO
                            au BufNewFile,BufRead *.mo,*.gdmo		setf gdmo
                            
                            " GDscript
                            au BufNewFile,BufRead *.gd			setf gdscript
                            
                            " Godot resource
                            au BufRead,BufNewFile *.tscn,*.tres		setf gdresource
                            
                            " Godot shader
                            au BufRead,BufNewFile *.gdshader,*.shader	setf gdshader
                            
                            " Gedcom
                            au BufNewFile,BufRead *.ged,lltxxxxx.txt	setf gedcom
                            
                            " Gemtext
                            au BufNewFile,BufRead *.gmi,*.gemini		setf gemtext
                            
                            " Gift (Moodle)
                            autocmd BufRead,BufNewFile *.gift		setf gift
                            
                            " Git
                            au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG 	setf gitcommit
                            au BufNewFile,BufRead NOTES_EDITMSG,EDIT_DESCRIPTION		setf gitcommit
                            au BufNewFile,BufRead *.git/config,.gitconfig,*/etc/gitconfig 	setf gitconfig
                            au BufNewFile,BufRead */.config/git/config			setf gitconfig
                            au BufNewFile,BufRead *.git/config.worktree			setf gitconfig
                            au BufNewFile,BufRead *.git/worktrees/*/config.worktree		setf gitconfig
                            au BufNewFile,BufRead .gitmodules,*.git/modules/*/config	setf gitconfig
                            if !empty($XDG_CONFIG_HOME)
                              au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config		setf gitconfig
                              au BufNewFile,BufRead $XDG_CONFIG_HOME/git/attributes		setf gitattributes
                              au BufNewFile,BufRead $XDG_CONFIG_HOME/git/ignore		setf gitignore
                            endif
                            au BufNewFile,BufRead .gitattributes,*.git/info/attributes	setf gitattributes
                            au BufNewFile,BufRead */.config/git/attributes			setf gitattributes
                            au BufNewFile,BufRead */etc/gitattributes			setf gitattributes
                            au BufNewFile,BufRead .gitignore,*.git/info/exclude		setf gitignore
                            au BufNewFile,BufRead */.config/git/ignore			setf gitignore
                            au BufNewFile,BufRead git-rebase-todo				setf gitrebase
                            au BufRead,BufNewFile .gitsendemail.msg.??????			setf gitsendemail
                            au BufNewFile,BufRead *.git/*
                                  \ if getline(1) =~# '^\x\{40,\}\>\|^ref: ' |
                                  \   setf git |
                                  \ endif
                            
                            " Gkrellmrc
                            au BufNewFile,BufRead gkrellmrc,gkrellmrc_?	setf gkrellmrc
                            
                            " Gleam
                            au BufNewFile,BufRead *.gleam			setf gleam
                            
                            " GLSL
                            au BufNewFile,BufRead *.glsl			setf glsl
                            
                            " GP scripts (2.0 and onward)
                            au BufNewFile,BufRead *.gp,.gprc		setf gp
                            
                            " GPG
                            au BufNewFile,BufRead */.gnupg/options		setf gpg
                            au BufNewFile,BufRead */.gnupg/gpg.conf		setf gpg
                            au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
                            if !empty($GNUPGHOME)
                              au BufNewFile,BufRead $GNUPGHOME/options	setf gpg
                              au BufNewFile,BufRead $GNUPGHOME/gpg.conf	setf gpg
                            endif
                            
                            " gnash(1) configuration files
                            au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
                            
                            " Gitolite
                            au BufNewFile,BufRead gitolite.conf		setf gitolite
                            au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc	setf perl
                            
                            " Glimmer-flavored TypeScript and JavaScript
                            au BufNewFile,BufRead *.gts			setf typescript.glimmer
                            au BufNewFile,BufRead *.gjs			setf javascript.glimmer
                            
                            " Gnuplot scripts
                            au BufNewFile,BufRead *.gpi,.gnuplot		setf gnuplot
                            
                            " Go (Google)
                            au BufNewFile,BufRead *.go			setf go
                            au BufNewFile,BufRead Gopkg.lock		setf toml
                            au BufRead,BufNewFile go.work			setf gowork
                            
                            " GrADS scripts
                            au BufNewFile,BufRead *.gs			setf grads
                            
                            " GraphQL
                            au BufNewFile,BufRead *.graphql,*.graphqls,*.gql			setf graphql
                            
                            " Gretl
                            au BufNewFile,BufRead *.gretl			setf gretl
                            
                            " Groovy
                            au BufNewFile,BufRead *.gradle,*.groovy		setf groovy
                            
                            " GNU Server Pages
                            au BufNewFile,BufRead *.gsp			setf gsp
                            
                            " Group file
                            au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
                            
                            " GTK RC
                            au BufNewFile,BufRead .gtkrc,gtkrc		setf gtkrc
                            
                            " GYP
                            au BufNewFile,BufRead *.gyp,*.gypi		setf gyp
                            
                            " Hack
                            au BufRead,BufNewFile *.hack,*.hackpartial			setf hack
                            
                            " Haml
                            au BufNewFile,BufRead *.haml			setf haml
                            
                            " Hamster Classic | Playground files
                            au BufNewFile,BufRead *.hsm			setf hamster
                            
                            " Handlebars
                            au BufNewFile,BufRead *.hbs			setf handlebars
                            
                            " Hare
                            au BufNewFile,BufRead *.ha			setf hare
                            
                            " Haskell
                            au BufNewFile,BufRead *.hs,*.hsc,*.hs-boot,*.hsig setf haskell
                            au BufNewFile,BufRead *.lhs			setf lhaskell
                            au BufNewFile,BufRead *.chs			setf chaskell
                            au BufNewFile,BufRead cabal.project		setf cabalproject
                            au BufNewFile,BufRead $HOME/.cabal/config	setf cabalconfig
                            au BufNewFile,BufRead cabal.config		setf cabalconfig
                            
                            " Haste
                            au BufNewFile,BufRead *.ht			setf haste
                            au BufNewFile,BufRead *.htpp			setf hastepreproc
                            
                            " HCL
                            au BufRead,BufNewFile *.hcl			setf hcl
                            
                            " Hercules
                            au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum	setf hercules
                            
                            " HEEx
                            au BufRead,BufNewFile *.heex			setf heex
                            
                            " HEX (Intel)
                            au BufNewFile,BufRead *.hex,*.h32		setf hex
                            
                            " Hjson
                            au BufNewFile,BufRead *.hjson			setf hjson
                            
                            " HLS Playlist (or another form of playlist)
                            au BufNewFile,BufRead *.m3u,*.m3u8		setf hlsplaylist
                            
                            " Hollywood
                            au BufRead,BufNewFile *.hws			setf hollywood
                            
                            " Hoon
                            au BufRead,BufNewFile *.hoon			setf hoon
                            
                            " Tilde (must be before HTML)
                            au BufNewFile,BufRead *.t.html			setf tilde
                            
                            " HTML (.shtml and .stm for server side)
                            au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call dist#ft#FThtml()
                            au BufNewFile,BufRead *.cshtml			setf html
                            
                            " HTML with Ruby - eRuby
                            au BufNewFile,BufRead *.erb,*.rhtml		setf eruby
                            
                            " HTML with M4
                            au BufNewFile,BufRead *.html.m4			setf htmlm4
                            
                            " Some template.  Used to be HTML Cheetah.
                            au BufNewFile,BufRead *.tmpl			setf template
                            
                            " Host config
                            au BufNewFile,BufRead */etc/host.conf		setf hostconf
                            
                            " Hosts access
                            au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
                            
                            " Hyper Builder
                            au BufNewFile,BufRead *.hb			setf hb
                            
                            " Httest
                            au BufNewFile,BufRead *.htt,*.htb		setf httest
                            
                            " i3
                            au BufNewFile,BufRead */i3/config		setf i3config
                            au BufNewFile,BufRead */.i3/config		setf i3config
                            
                            " sway
                            au BufNewFile,BufRead */sway/config		setf swayconfig
                            au BufNewFile,BufRead */.sway/config		setf swayconfig
                            
                            " Icon
                            au BufNewFile,BufRead *.icn			setf icon
                            
                            " IDL (Interface Description Language)
                            au BufNewFile,BufRead *.idl			call dist#ft#FTidl()
                            
                            " Microsoft IDL (Interface Description Language)  Also *.idl
                            " MOF = WMI (Windows Management Instrumentation) Managed Object Format
                            au BufNewFile,BufRead *.odl,*.mof		setf msidl
                            
                            " Icewm menu
                            au BufNewFile,BufRead */.icewm/menu		setf icemenu
                            
                            " Indent profile (must come before IDL *.pro!)
                            au BufNewFile,BufRead .indent.pro		setf indent
                            au BufNewFile,BufRead indent.pro		call dist#ft#ProtoCheck('indent')
                            
                            " IDL (Interactive Data Language)
                            au BufNewFile,BufRead *.pro			call dist#ft#ProtoCheck('idlang')
                            
                            " Indent RC
                            au BufNewFile,BufRead indentrc			setf indent
                            
                            " Inform
                            au BufNewFile,BufRead *.inf,*.INF		setf inform
                            
                            " Initng
                            au BufNewFile,BufRead */etc/initng/*/*.i,*.ii	setf initng
                            
                            " Innovation Data Processing
                            au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c	setf upstreamdat
                            au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c	setf upstreamlog
                            au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
                            au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c	setf usserverlog
                            au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c	setf usw2kagtlog
                            
                            " Ipfilter
                            au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules	setf ipfilter
                            
                            " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
                            au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl	setf fgl
                            
                            " .INI file for MSDOS
                            au BufNewFile,BufRead *.ini			setf dosini
                            
                            " SysV Inittab
                            au BufNewFile,BufRead inittab			setf inittab
                            
                            " Inno Setup
                            au BufNewFile,BufRead *.iss			setf iss
                            
                            " J
                            au BufNewFile,BufRead *.ijs			setf j
                            
                            " JAL
                            au BufNewFile,BufRead *.jal,*.JAL		setf jal
                            
                            " Jam
                            au BufNewFile,BufRead *.jpl,*.jpr		setf jam
                            
                            " Java
                            au BufNewFile,BufRead *.java,*.jav		setf java
                            
                            " JavaCC
                            au BufNewFile,BufRead *.jj,*.jjt		setf javacc
                            
                            " JavaScript, ECMAScript, ES module script, CommonJS script
                            au BufNewFile,BufRead *.js,*.jsm,*.javascript,*.es,*.mjs,*.cjs   setf javascript
                            
                            " JavaScript with React
                            au BufNewFile,BufRead *.jsx			setf javascriptreact
                            
                            " Java Server Pages
                            au BufNewFile,BufRead *.jsp			setf jsp
                            
                            " Java Properties resource file (note: doesn't catch font.properties.pl)
                            au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??	setf jproperties
                            
                            " Jess
                            au BufNewFile,BufRead *.clp			setf jess
                            
                            " Jgraph
                            au BufNewFile,BufRead *.jgr			setf jgraph
                            
                            " Jovial
                            au BufNewFile,BufRead *.jov,*.j73,*.jovial	setf jovial
                            
                            " JSON
                            au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest	setf json
                            
                            " JSON5
                            au BufNewFile,BufRead *.json5			setf json5
                            
                            " JSON Patch (RFC 6902)
                            au BufNewFile,BufRead *.json-patch			setf json
                            
                            " Jupyter Notebook is also json
                            au BufNewFile,BufRead *.ipynb				setf json
                            
                            " Other files that look like json
                            au BufNewFile,BufRead .babelrc,.eslintrc,.prettierrc,.firebaserc  setf json
                            
                            " JSONC
                            au BufNewFile,BufRead *.jsonc			setf jsonc
                            
                            " Jsonnet
                            au BufNewFile,BufRead *.jsonnet,*.libjsonnet	setf jsonnet
                            
                            " Julia
                            au BufNewFile,BufRead *.jl			setf julia
                            
                            " Kixtart
                            au BufNewFile,BufRead *.kix			setf kix
                            
                            " Kuka Robot Language
                            au BufNewFile,BufRead *.src\c			call dist#ft#FTsrc()
                            au BufNewFile,BufRead *.dat\c			call dist#ft#FTdat()
                            au BufNewFile,BufRead *.sub\c			setf krl
                            
                            " Kimwitu[++]
                            au BufNewFile,BufRead *.k			setf kwt
                            
                            " Kivy
                            au BufNewFile,BufRead *.kv			setf kivy
                            
                            " Kotlin
                            au BufNewFile,BufRead *.kt,*.ktm,*.kts		setf kotlin
                            
                            " KDE script
                            au BufNewFile,BufRead *.ks			setf kscript
                            
                            " Kconfig
                            au BufNewFile,BufRead Kconfig,Kconfig.debug	setf kconfig
                            
                            " Lace (ISE)
                            au BufNewFile,BufRead *.ace,*.ACE		setf lace
                            
                            " Latexmkrc
                            au BufNewFile,BufRead .latexmkrc,latexmkrc	setf perl
                            
                            " Latte
                            au BufNewFile,BufRead *.latte,*.lte		setf latte
                            
                            " Limits
                            au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf	setf limits
                            
                            " LambdaProlog or SML (see dist#ft#FTmod for *.mod)
                            au BufNewFile,BufRead *.sig			call dist#ft#FTsig()
                            
                            " LDAP LDIF
                            au BufNewFile,BufRead *.ldif			setf ldif
                            
                            " Ld loader
                            au BufNewFile,BufRead *.ld			setf ld
                            
                            " Ledger
                            au BufRead,BufNewFile *.ldg,*.ledger,*.journal			setf ledger
                            
                            " Less
                            au BufNewFile,BufRead *.less			setf less
                            
                            " Lex
                            au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++	setf lex
                            
                            " Libao
                            au BufNewFile,BufRead */etc/libao.conf,*/.libao	setf libao
                            
                            " Libsensors
                            au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf	setf sensors
                            
                            " LFTP
                            au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc	setf lftp
                            
                            " Lifelines (or Lex for C++!)
                            au BufNewFile,BufRead *.ll			setf lifelines
                            
                            " Lilo: Linux loader
                            au BufNewFile,BufRead lilo.conf			setf lilo
                            
                            " Lilypond
                            au BufNewFile,BufRead *.ly,*.ily		setf lilypond
                            
                            " Lisp (*.el = ELisp, *.cl = Common Lisp)
                            " *.jl was removed, it's also used for Julia, better skip than guess wrong.
                            if has("fname_case")
                              au BufNewFile,BufRead *.lsp,*.lisp,*.asd,*.el,*.cl,*.L,.emacs,.sawfishrc setf lisp
                            else
                              au BufNewFile,BufRead *.lsp,*.lisp,*.asd,*.el,*.cl,.emacs,.sawfishrc setf lisp
                            endif
                            
                            " SBCL implementation of Common Lisp
                            au BufNewFile,BufRead sbclrc,.sbclrc		setf lisp
                            
                            " Liquid
                            au BufNewFile,BufRead *.liquid			setf liquid
                            
                            " Lite
                            au BufNewFile,BufRead *.lite,*.lt		setf lite
                            
                            " LiteStep RC files
                            au BufNewFile,BufRead */LiteStep/*/*.rc		setf litestep
                            
                            " Login access
                            au BufNewFile,BufRead */etc/login.access	setf loginaccess
                            
                            " Login defs
                            au BufNewFile,BufRead */etc/login.defs		setf logindefs
                            
                            " Logtalk
                            au BufNewFile,BufRead *.lgt			setf logtalk
                            
                            " LOTOS
                            au BufNewFile,BufRead *.lot,*.lotos		setf lotos
                            
                            " Lout (also: *.lt)
                            au BufNewFile,BufRead *.lou,*.lout		setf lout
                            
                            " Lua
                            au BufNewFile,BufRead *.lua			setf lua
                            
                            " Luacheck
                            au BufNewFile,BufRead .luacheckrc		setf lua
                            
                            " Luarocks
                            au BufNewFile,BufRead *.rockspec		setf lua
                            
                            " Linden Scripting Language (Second Life)
                            au BufNewFile,BufRead *.lsl			setf lsl
                            
                            " Lynx style file (or LotusScript!)
                            au BufNewFile,BufRead *.lss			setf lss
                            
                            " M4
                            au BufNewFile,BufRead *.m4
                            	\ if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
                            
                            " MaGic Point
                            au BufNewFile,BufRead *.mgp			setf mgp
                            
                            " Mail (for Elm, trn, mutt, muttng, rn, slrn, neomutt)
                            au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},neomutt-*-\w\+,neomutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
                            
                            " Mail aliases
                            au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases	setf mailaliases
                            
                            " Mailcap configuration file
                            au BufNewFile,BufRead .mailcap,mailcap		setf mailcap
                            
                            " Makefile
                            au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
                            
                            " MakeIndex
                            au BufNewFile,BufRead *.ist,*.mst		setf ist
                            
                            " Mallard
                            au BufNewFile,BufRead *.page			setf mallard
                            
                            " Manpage
                            au BufNewFile,BufRead *.man			setf nroff
                            
                            " Man config
                            au BufNewFile,BufRead */etc/man.conf,man.config	setf manconf
                            
                            " Maple V
                            au BufNewFile,BufRead *.mv,*.mpl,*.mws		setf maple
                            
                            " Map (UMN mapserver config file)
                            au BufNewFile,BufRead *.map			setf map
                            
                            " Markdown
                            au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
                            
                            " Mason
                            au BufNewFile,BufRead *.mason,*.mhtml,*.comp	setf mason
                            
                            " Mathematica, Matlab, Murphi, Objective C or Octave
                            au BufNewFile,BufRead *.m			call dist#ft#FTm()
                            
                            " Mathematica notebook
                            au BufNewFile,BufRead *.nb			setf mma
                            
                            " Maya Extension Language
                            au BufNewFile,BufRead *.mel			setf mel
                            
                            " Mercurial (hg) commit file
                            au BufNewFile,BufRead hg-editor-*.txt		setf hgcommit
                            
                            " Mercurial config (looks like generic config file)
                            au BufNewFile,BufRead *.hgrc,*hgrc		setf cfg
                            
                            " Meson Build system config
                            au BufNewFile,BufRead meson.build,meson_options.txt setf meson
                            au BufNewFile,BufRead *.wrap			setf dosini
                            
                            " Messages (logs mostly)
                            au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
                            
                            " Metafont
                            au BufNewFile,BufRead *.mf			setf mf
                            
                            " MetaPost
                            au BufNewFile,BufRead *.mp			setf mp
                            au BufNewFile,BufRead *.mpxl,*.mpiv,*.mpvi	let b:mp_metafun = 1 | setf mp
                            
                            " MGL
                            au BufNewFile,BufRead *.mgl			setf mgl
                            
                            " MIX - Knuth assembly
                            au BufNewFile,BufRead *.mix,*.mixal		setf mix
                            
                            " MMIX or VMS makefile
                            au BufNewFile,BufRead *.mms			call dist#ft#FTmms()
                            
                            " Symbian meta-makefile definition (MMP)
                            au BufNewFile,BufRead *.mmp			setf mmp
                            
                            " ABB Rapid, Modula-2, Modsim III or LambdaProlog
                            au BufNewFile,BufRead *.mod\c			call dist#ft#FTmod()
                            
                            " Modula-2  (.md removed in favor of Markdown, see dist#ft#FTmod for *.MOD)
                            au BufNewFile,BufRead *.m2,*.DEF,*.mi		setf modula2
                            
                            " Modula-3 (.m3, .i3, .mg, .ig)
                            au BufNewFile,BufRead *.[mi][3g]		setf modula3
                            
                            " Monk
                            au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc	setf monk
                            
                            " MOO
                            au BufNewFile,BufRead *.moo			setf moo
                            
                            " Moonscript
                            au BufNewFile,BufRead *.moon			setf moonscript
                            
                            " Modconf
                            au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
                            
                            " MPD is based on XML
                            au BufNewFile,BufRead *.mpd			setf xml
                            
                            " Mplayer config
                            au BufNewFile,BufRead mplayer.conf,*/.mplayer/config	setf mplayerconf
                            
                            " Motorola S record
                            au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec	setf srec
                            
                            " Mrxvtrc
                            au BufNewFile,BufRead mrxvtrc,.mrxvtrc		setf mrxvtrc
                            
                            " Msql
                            au BufNewFile,BufRead *.msql			setf msql
                            
                            " Mysql
                            au BufNewFile,BufRead *.mysql			setf mysql
                            
                            " Tcl Shell RC file
                            au BufNewFile,BufRead tclsh.rc			setf tcl
                            
                            " M$ Resource files
                            " /etc/Muttrc.d/file.rc is muttrc
                            au BufNewFile,BufRead *.rc,*.rch
                            	\ if expand("<afile>") !~ "/etc/Muttrc.d/" |
                            	\   setf rc |
                            	\ endif
                            
                            " MuPAD source
                            au BufRead,BufNewFile *.mu			setf mupad
                            
                            " Mush
                            au BufNewFile,BufRead *.mush			setf mush
                            
                            " Mutt setup file (also for Muttng)
                            au BufNewFile,BufRead Mutt{ng,}rc		setf muttrc
                            
                            " N1QL
                            au BufRead,BufNewfile *.n1ql,*.nql		setf n1ql
                            
                            " Nano
                            au BufNewFile,BufRead */etc/nanorc,*.nanorc	setf nanorc
                            
                            " Nastran input/DMAP
                            "au BufNewFile,BufRead *.dat			setf nastran
                            
                            " Natural
                            au BufNewFile,BufRead *.NS[ACGLMNPS]		setf natural
                            
                            " Noemutt setup file
                            au BufNewFile,BufRead Neomuttrc			setf neomuttrc
                            
                            " Netrc
                            au BufNewFile,BufRead .netrc			setf netrc
                            
                            " Nginx
                            au BufNewFile,BufRead *.nginx,nginx*.conf,*nginx.conf,*/etc/nginx/*,*/usr/local/nginx/conf/*,*/nginx/*.conf			setf nginx
                            
                            " Nim file
                            au BufNewFile,BufRead *.nim,*.nims,*.nimble	setf nim
                            
                            " Ninja file
                            au BufNewFile,BufRead *.ninja			setf ninja
                            
                            " Nix
                            au BufRead,BufNewFile *.nix			setf nix
                            
                            " NPM RC file
                            au BufNewFile,BufRead npmrc,.npmrc		setf dosini
                            
                            " Novell netware batch files
                            au BufNewFile,BufRead *.ncf			setf ncf
                            
                            " Nroff/Troff (*.ms and *.t are checked below)
                            au BufNewFile,BufRead *.me
                            	\ if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |
                            	\   setf nroff |
                            	\ endif
                            au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom	setf nroff
                            au BufNewFile,BufRead *.[1-9]			call dist#ft#FTnroff()
                            
                            " Nroff or Objective C++
                            au BufNewFile,BufRead *.mm			call dist#ft#FTmm()
                            
                            " Not Quite C
                            au BufNewFile,BufRead *.nqc			setf nqc
                            
                            " NSE - Nmap Script Engine - uses Lua syntax
                            au BufNewFile,BufRead *.nse			setf lua
                            
                            " NSIS
                            au BufNewFile,BufRead *.nsi,*.nsh		setf nsis
                            
                            " OCaml
                            au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit,*.mlt,*.mlp,*.mlip,*.mli.cppo,*.ml.cppo setf ocaml
                            
                            " Occam
                            au BufNewFile,BufRead *.occ			setf occam
                            
                            " Octave
                            au BufNewFile,BufRead octave.conf,.octaverc,octaverc	setf octave
                            
                            " Omnimark
                            au BufNewFile,BufRead *.xom,*.xin		setf omnimark
                            
                            " OPAM
                            au BufNewFile,BufRead opam,*.opam,*.opam.template setf opam
                            
                            " OpenFOAM
                            au BufNewFile,BufRead [a-zA-Z0-9]*Dict\(.*\)\=,[a-zA-Z]*Properties\(.*\)\=,*Transport\(.*\),fvSchemes,fvSolution,fvConstrains,fvModels,*/constant/g,*/0\(\.orig\)\=/* call dist#ft#FTfoam()
                            
                            " OpenROAD
                            au BufNewFile,BufRead *.or				setf openroad
                            
                            " OPL
                            au BufNewFile,BufRead *.[Oo][Pp][Ll]			setf opl
                            
                            " OpenSCAD
                            au BufNewFile,BufRead *.scad				setf openscad
                            
                            " Oracle config file
                            au BufNewFile,BufRead *.ora				setf ora
                            
                            " Org
                            au BufNewFile,BufRead *.org,*.org_archive		setf org
                            
                            " Packet filter conf
                            au BufNewFile,BufRead pf.conf				setf pf
                            
                            " ini style config files, using # comments
                            au BufNewFile,BufRead */etc/pacman.conf,mpv.conf	setf confini
                            
                            " Pacman hooks
                            au BufNewFile,BufRead *.hook
                            	\ if getline(1) == '[Trigger]' |
                            	\   setf conf |
                            	\ endif
                            
                            " Pam conf
                            au BufNewFile,BufRead */etc/pam.conf			setf pamconf
                            
                            " Pam environment
                            au BufNewFile,BufRead pam_env.conf,.pam_environment	setf pamenv
                            
                            " PApp
                            au BufNewFile,BufRead *.papp,*.pxml,*.pxsl		setf papp
                            
                            " Password file
                            au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
                            
                            " Pascal (also *.p, *.pp, *.inc)
                            au BufNewFile,BufRead *.pas				setf pascal
                            
                            " Pascal or Puppet manifest
                            au BufNewFile,BufRead *.pp				call dist#ft#FTpp()
                            
                            " Delphi or Lazarus program file
                            au BufNewFile,BufRead *.dpr,*.lpr			setf pascal
                            
                            " Free Pascal makefile definition file
                            au BufNewFile,BufRead *.fpc				setf fpcmake
                            
                            " PDF
                            au BufNewFile,BufRead *.pdf				setf pdf
                            
                            " PCMK - HAE - crm configure edit
                            au BufNewFile,BufRead *.pcmk				setf pcmk
                            
                            " Perl
                            if has("fname_case")
                              au BufNewFile,BufRead *.pl,*.PL			call dist#ft#FTpl()
                            else
                              au BufNewFile,BufRead *.pl				call dist#ft#FTpl()
                            endif
                            au BufNewFile,BufRead *.plx,*.al,*.psgi			setf perl
                            
                            " Perl, XPM or XPM2
                            au BufNewFile,BufRead *.pm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ elseif getline(1) =~ "XPM" |
                            	\   setf xpm |
                            	\ else |
                            	\   setf perl |
                            	\ endif
                            
                            " Perl POD
                            au BufNewFile,BufRead *.pod			setf pod
                            
                            " Php, php3, php4, etc.
                            " Also Phtml (was used for PHP 2 in the past).
                            " Also .ctp for Cake template file.
                            " Also .phpt for php tests.
                            " Also .theme for Drupal theme files.
                            au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp,*.phpt,*.theme	setf php
                            
                            " PHP config
                            au BufNewFile,BufRead php.ini-*			setf dosini
                            
                            " Pike and Cmod
                            au BufNewFile,BufRead *.pike,*.pmod		setf pike
                            au BufNewFile,BufRead *.cmod			setf cmod
                            
                            " Pinfo config
                            au BufNewFile,BufRead */etc/pinforc,*/.pinforc	setf pinfo
                            
                            " Palm Resource compiler
                            au BufNewFile,BufRead *.rcp			setf pilrc
                            
                            " Pine config
                            au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex		setf pine
                            
                            " Pipenv Pipfiles
                            au BufNewFile,BufRead Pipfile			setf toml
                            au BufNewFile,BufRead Pipfile.lock		setf json
                            
                            " PL/1, PL/I
                            au BufNewFile,BufRead *.pli,*.pl1		setf pli
                            
                            " PL/M (also: *.inp)
                            au BufNewFile,BufRead *.plm,*.p36,*.pac		setf plm
                            
                            " PL/SQL
                            au BufNewFile,BufRead *.pls,*.plsql		setf plsql
                            
                            " PLP
                            au BufNewFile,BufRead *.plp			setf plp
                            
                            " PO and PO template (GNU gettext)
                            au BufNewFile,BufRead *.po,*.pot		setf po
                            
                            " Postfix main config
                            au BufNewFile,BufRead main.cf			setf pfmain
                            
                            " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
                            au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai	  setf postscr
                            
                            " PostScript Printer Description
                            au BufNewFile,BufRead *.ppd			setf ppd
                            
                            " Povray
                            au BufNewFile,BufRead *.pov			setf pov
                            
                            " Povray configuration
                            au BufNewFile,BufRead .povrayrc			setf povini
                            
                            " Povray, Pascal, PHP or assembly
                            au BufNewFile,BufRead *.inc			call dist#ft#FTinc()
                            
                            " PowerShell
                            au BufNewFile,BufRead	*.ps1,*.psd1,*.psm1,*.pssc	setf ps1
                            au BufNewFile,BufRead	*.ps1xml			setf ps1xml
                            au BufNewFile,BufRead	*.cdxml,*.psc1			setf xml
                            
                            " Printcap and Termcap
                            au BufNewFile,BufRead *printcap
                            	\ let b:ptcap_type = "print" | setf ptcap
                            au BufNewFile,BufRead *termcap
                            	\ let b:ptcap_type = "term" | setf ptcap
                            
                            " Prisma
                            au BufRead,BufNewFile *.prisma			setf prisma
                            
                            " PCCTS / ANTLR
                            "au BufNewFile,BufRead *.g			setf antlr
                            au BufNewFile,BufRead *.g			setf pccts
                            
                            " PPWizard
                            au BufNewFile,BufRead *.it,*.ih			setf ppwiz
                            
                            " Pug
                            au BufRead,BufNewFile *.pug			setf pug
                            
                            " Puppet
                            au BufNewFile,BufRead Puppetfile		setf ruby
                            
                            " Embedded Puppet
                            au BufNewFile,BufRead *.epp			setf epuppet
                            
                            " Obj 3D file format
                            " TODO: is there a way to avoid MS-Windows Object files?
                            au BufNewFile,BufRead *.obj			setf obj
                            
                            " Oracle Pro*C/C++
                            au BufNewFile,BufRead *.pc			setf proc
                            
                            " Privoxy actions file
                            au BufNewFile,BufRead *.action			setf privoxy
                            
                            " Procmail
                            au BufNewFile,BufRead .procmail,.procmailrc	setf procmail
                            
                            " Progress or CWEB
                            au BufNewFile,BufRead *.w			call dist#ft#FTprogress_cweb()
                            
                            " Progress or assembly
                            au BufNewFile,BufRead *.i			call dist#ft#FTprogress_asm()
                            
                            " Progress or Pascal
                            au BufNewFile,BufRead *.p			call dist#ft#FTprogress_pascal()
                            
                            " Software Distributor Product Specification File (POSIX 1387.2-1995)
                            au BufNewFile,BufRead *.psf			setf psf
                            au BufNewFile,BufRead INDEX,INFO
                            	\ if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |
                            	\   setf psf |
                            	\ endif
                            
                            " Prolog
                            au BufNewFile,BufRead *.pdb			setf prolog
                            
                            " Promela
                            au BufNewFile,BufRead *.pml			setf promela
                            
                            " Property Specification Language (PSL)
                            au BufNewFile,BufRead *.psl			setf psl
                            
                            " Google protocol buffers
                            au BufNewFile,BufRead *.proto			setf proto
                            au BufNewFile,BufRead *.pbtxt			setf pbtxt
                            
                            " Poke
                            au BufNewFile,BufRead *.pk			setf poke
                            
                            " Protocols
                            au BufNewFile,BufRead */etc/protocols		setf protocols
                            
                            " Pyret
                            au BufNewFile,BufRead *.arr			setf pyret
                            
                            " Pyrex
                            au BufNewFile,BufRead *.pyx,*.pxd		setf pyrex
                            
                            " Python, Python Shell Startup and Python Stub Files
                            " Quixote (Python-based web framework)
                            au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc  setf python
                            au BufNewFile,BufRead *.ptl,*.pyi,SConstruct		   setf python
                            
                            " QL
                            au BufRead,BufNewFile *.ql,*.qll		setf ql
                            
                            " Quarto
                            au BufRead,BufNewFile *.qmd     setf quarto
                            
                            " Radiance
                            au BufNewFile,BufRead *.rad,*.mat		setf radiance
                            
                            " Raku (formerly Perl6)
                            au BufNewFile,BufRead *.pm6,*.p6,*.t6,*.pod6,*.raku,*.rakumod,*.rakudoc,*.rakutest  setf raku
                            
                            " Ratpoison config/command files
                            au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc	setf ratpoison
                            
                            " RCS file
                            au BufNewFile,BufRead *\,v			setf rcs
                            
                            " Readline
                            au BufNewFile,BufRead .inputrc,inputrc		setf readline
                            
                            " Registry for MS-Windows
                            au BufNewFile,BufRead *.reg
                            	\ if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
                            
                            " Renderman Interface Bytestream
                            au BufNewFile,BufRead *.rib			setf rib
                            
                            " Rego Policy Language
                            au BufNewFile,BufRead *.rego			setf rego
                            
                            " Rexx
                            au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit	setf rexx
                            
                            " R Help file
                            if has("fname_case")
                              au BufNewFile,BufRead *.rd,*.Rd		setf rhelp
                            else
                              au BufNewFile,BufRead *.rd			setf rhelp
                            endif
                            
                            " R noweb file
                            if has("fname_case")
                              au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw		setf rnoweb
                            else
                              au BufNewFile,BufRead *.rnw,*.snw			setf rnoweb
                            endif
                            
                            " R Markdown file
                            if has("fname_case")
                              au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd		setf rmd
                            else
                              au BufNewFile,BufRead *.rmd,*.smd			setf rmd
                            endif
                            
                            " RSS looks like XML
                            au BufNewFile,BufRead *.rss				setf xml
                            
                            " R reStructuredText file
                            if has("fname_case")
                              au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst	setf rrst
                            else
                              au BufNewFile,BufRead *.rrst,*.srst			setf rrst
                            endif
                            
                            " Rexx, Rebol or R
                            au BufNewFile,BufRead *.r,*.R				call dist#ft#FTr()
                            
                            " Remind
                            au BufNewFile,BufRead .reminders,*.remind,*.rem		setf remind
                            
                            " ReScript
                            au BufNewFile,BufRead *.res,*.resi			setf rescript
                            
                            " Resolv.conf
                            au BufNewFile,BufRead resolv.conf		setf resolv
                            
                            " Relax NG Compact
                            au BufNewFile,BufRead *.rnc			setf rnc
                            
                            " Relax NG XML
                            au BufNewFile,BufRead *.rng			setf rng
                            
                            " RPL/2
                            au BufNewFile,BufRead *.rpl			setf rpl
                            
                            " Robot Framework
                            au BufNewFile,BufRead *.robot,*.resource	setf robot
                            
                            " Robots.txt
                            au BufNewFile,BufRead robots.txt		setf robots
                            
                            " Rpcgen
                            au BufNewFile,BufRead *.x			setf rpcgen
                            
                            " MikroTik RouterOS script
                            au BufRead,BufNewFile *.rsc			setf routeros
                            
                            " reStructuredText Documentation Format
                            au BufNewFile,BufRead *.rst			setf rst
                            
                            " RTF
                            au BufNewFile,BufRead *.rtf			setf rtf
                            
                            " Interactive Ruby shell
                            au BufNewFile,BufRead .irbrc,irbrc		setf ruby
                            
                            " Ruby
                            au BufNewFile,BufRead *.rb,*.rbw		setf ruby
                            
                            " RubyGems
                            au BufNewFile,BufRead *.gemspec			setf ruby
                            
                            " RBS (Ruby Signature)
                            au BufNewFile,BufRead *.rbs			setf rbs
                            
                            " Rackup
                            au BufNewFile,BufRead *.ru			setf ruby
                            
                            " Bundler
                            au BufNewFile,BufRead Gemfile			setf ruby
                            
                            " Ruby on Rails
                            au BufNewFile,BufRead *.builder,*.rxml,*.rjs	setf ruby
                            
                            " Rantfile and Rakefile is like Ruby
                            au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake	setf ruby
                            
                            " Rust
                            au BufNewFile,BufRead *.rs			setf rust
                            au BufNewFile,BufRead Cargo.lock,*/.cargo/config,*/.cargo/credentials	setf toml
                            
                            " S-lang (or shader language, or SmallLisp)
                            au BufNewFile,BufRead *.sl			setf slang
                            
                            " Samba config
                            au BufNewFile,BufRead smb.conf			setf samba
                            
                            " SAS script
                            au BufNewFile,BufRead *.sas			setf sas
                            
                            " Sass
                            au BufNewFile,BufRead *.sass			setf sass
                            
                            " Sather
                            au BufNewFile,BufRead *.sa			setf sather
                            
                            " Scala
                            au BufNewFile,BufRead *.scala			setf scala
                            
                            " SBT - Scala Build Tool
                            au BufNewFile,BufRead *.sbt			setf sbt
                            
                            " SuperCollider
                            au BufNewFile,BufRead *.sc			call dist#ft#FTsc()
                            
                            au BufNewFile,BufRead *.quark			setf supercollider
                            
                            " scdoc
                            au BufNewFile,BufRead *.scd			call dist#ft#FTscd()
                            
                            " Scilab
                            au BufNewFile,BufRead *.sci,*.sce		setf scilab
                            
                            
                            " SCSS
                            au BufNewFile,BufRead *.scss			setf scss
                            
                            " SD: Streaming Descriptors
                            au BufNewFile,BufRead *.sd			setf sd
                            
                            " SDL
                            au BufNewFile,BufRead *.sdl,*.pr		setf sdl
                            
                            " sed
                            au BufNewFile,BufRead *.sed			setf sed
                            
                            " SubRip
                            au BufNewFile,BufRead *.srt			setf srt
                            
                            " svelte
                            au BufNewFile,BufRead *.svelte			setf svelte
                            
                            " Sieve (RFC 3028, 5228)
                            au BufNewFile,BufRead *.siv,*.sieve		setf sieve
                            
                            " Sendmail
                            au BufNewFile,BufRead sendmail.cf		setf sm
                            
                            " Sendmail .mc files are actually m4.  Could also be MS Message text file or
                            " Maxima.
                            au BufNewFile,BufRead *.mc			call dist#ft#McSetf()
                            
                            " Services
                            au BufNewFile,BufRead */etc/services		setf services
                            
                            " Service Location config
                            au BufNewFile,BufRead */etc/slp.conf		setf slpconf
                            
                            " Service Location registration
                            au BufNewFile,BufRead */etc/slp.reg		setf slpreg
                            
                            " Service Location SPI
                            au BufNewFile,BufRead */etc/slp.spi		setf slpspi
                            
                            " Setserial config
                            au BufNewFile,BufRead */etc/serial.conf		setf setserial
                            
                            " SGML
                            au BufNewFile,BufRead *.sgm,*.sgml
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |
                            	\   setf sgmllnx |
                            	\ elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |
                            	\   let b:docbk_type = "sgml" |
                            	\   let b:docbk_ver = 4 |
                            	\   setf docbk |
                            	\ else |
                            	\   setf sgml |
                            	\ endif
                            
                            " SGMLDECL
                            au BufNewFile,BufRead *.decl,*.dcl,*.dec
                            	\ if getline(1).getline(2).getline(3) =~? '^<!SGML' |
                            	\    setf sgmldecl |
                            	\ endif
                            
                            " SGML catalog file
                            au BufNewFile,BufRead catalog			setf catalog
                            
                            " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
                            " Gentoo ebuilds, Arch Linux PKGBUILDs and Alpine Linux APKBUILDs are actually
                            " bash scripts.
                            " NOTE: Patterns ending in a star are further down, these have lower priority.
                            au BufNewFile,BufRead .bashrc,bashrc,bash.bashrc,.bash[_-]profile,.bash[_-]logout,.bash[_-]aliases,bash-fc[-.],*.ebuild,*.bash,*.eclass,PKGBUILD,APKBUILD call dist#ft#SetFileTypeSH("bash")
                            au BufNewFile,BufRead .kshrc,*.ksh call dist#ft#SetFileTypeSH("ksh")
                            au BufNewFile,BufRead */etc/profile,.profile,*.sh,*.env call dist#ft#SetFileTypeSH(getline(1))
                            
                            " Shell script (Arch Linux) or PHP file (Drupal)
                            au BufNewFile,BufRead *.install
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   call dist#ft#SetFileTypeSH("bash") |
                            	\ endif
                            
                            " tcsh scripts (patterns ending in a star further below)
                            au BufNewFile,BufRead .tcshrc,*.tcsh,tcsh.tcshrc,tcsh.login	call dist#ft#SetFileTypeShell("tcsh")
                            
                            " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
                            " (patterns ending in a start further below)
                            au BufNewFile,BufRead .login,.cshrc,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call dist#ft#CSH()
                            
                            " Zig
                            au BufNewFile,BufRead *.zig			setf zig
                            
                            " Z-Shell script (patterns ending in a star further below)
                            au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
                            au BufNewFile,BufRead .zshrc,.zshenv,.zlogin,.zlogout,.zcompdump setf zsh
                            au BufNewFile,BufRead *.zsh			setf zsh
                            
                            " Scheme
                            au BufNewFile,BufRead *.scm,*.ss,*.sld,*.rkt,*.rktd,*.rktl	setf scheme
                            
                            " Screen RC
                            au BufNewFile,BufRead .screenrc,screenrc	setf screen
                            
                            " Sexplib
                            au BufNewFile,BufRead *.sexp setf sexplib
                            
                            " Simula
                            au BufNewFile,BufRead *.sim			setf simula
                            
                            " SINDA
                            au BufNewFile,BufRead *.sin,*.s85		setf sinda
                            
                            " SiSU
                            au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
                            au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
                            
                            " SKILL
                            au BufNewFile,BufRead *.il,*.ils,*.cdf		setf skill
                            
                            " SLRN
                            au BufNewFile,BufRead .slrnrc			setf slrnrc
                            au BufNewFile,BufRead *.score			setf slrnsc
                            
                            " Smalltalk
                            au BufNewFile,BufRead *.st			setf st
                            
                            " Smalltalk (and Rexx, TeX, and Visual Basic)
                            au BufNewFile,BufRead *.cls			call dist#ft#FTcls()
                            
                            " Smarty templates
                            au BufNewFile,BufRead *.tpl			setf smarty
                            
                            " SMIL or XML
                            au BufNewFile,BufRead *.smil
                            	\ if getline(1) =~ '<?\s*xml.*?>' |
                            	\   setf xml |
                            	\ else |
                            	\   setf smil |
                            	\ endif
                            
                            " SMIL or SNMP MIB file
                            au BufNewFile,BufRead *.smi
                            	\ if getline(1) =~ '\<smil\>' |
                            	\   setf smil |
                            	\ else |
                            	\   setf mib |
                            	\ endif
                            
                            " SMITH
                            au BufNewFile,BufRead *.smt,*.smith		setf smith
                            
                            " Snobol4 and spitbol
                            au BufNewFile,BufRead *.sno,*.spt		setf snobol4
                            
                            " SNMP MIB files
                            au BufNewFile,BufRead *.mib,*.my		setf mib
                            
                            " Snort Configuration
                            au BufNewFile,BufRead *.hog,snort.conf,vision.conf	setf hog
                            au BufNewFile,BufRead *.rules			call dist#ft#FTRules()
                            
                            " Solidity
                            au BufRead,BufNewFile *.sol			setf solidity
                            
                            " SPARQL queries
                            au BufNewFile,BufRead *.rq,*.sparql		setf sparql
                            
                            " Spec (Linux RPM)
                            au BufNewFile,BufRead *.spec			setf spec
                            
                            " Speedup (AspenTech plant simulator)
                            au BufNewFile,BufRead *.speedup,*.spdata,*.spd	setf spup
                            
                            " Slice
                            au BufNewFile,BufRead *.ice			setf slice
                            
                            " Microsoft Visual Studio Solution
                            au BufNewFile,BufRead *.sln			setf solution
                            au BufNewFile,BufRead *.slnf			setf json
                            
                            " Spice
                            au BufNewFile,BufRead *.sp,*.spice		setf spice
                            
                            " Spyce
                            au BufNewFile,BufRead *.spy,*.spi		setf spyce
                            
                            " Squid
                            au BufNewFile,BufRead squid.conf		setf squid
                            
                            " SQL for Oracle Designer
                            au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks	setf sql
                            
                            " SQL
                            au BufNewFile,BufRead *.sql			call dist#ft#SQL()
                            
                            " SQLJ
                            au BufNewFile,BufRead *.sqlj			setf sqlj
                            
                            " SQR
                            au BufNewFile,BufRead *.sqr,*.sqi		setf sqr
                            
                            " Squirrel
                            au BufNewFile,BufRead *.nut			setf squirrel
                            
                            " OpenSSH configuration
                            au BufNewFile,BufRead ssh_config,*/.ssh/config,*/.ssh/*.conf	setf sshconfig
                            au BufNewFile,BufRead */etc/ssh/ssh_config.d/*.conf		setf sshconfig
                            
                            " OpenSSH server configuration
                            au BufNewFile,BufRead sshd_config			setf sshdconfig
                            au BufNewFile,BufRead */etc/ssh/sshd_config.d/*.conf	setf sshdconfig
                            
                            " Stata
                            au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata	setf stata
                            " Also *.class, but not when it's a Java bytecode file
                            au BufNewFile,BufRead *.class
                            	\ if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif
                            
                            " SMCL
                            au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl	setf smcl
                            
                            " Stored Procedures
                            au BufNewFile,BufRead *.stp			setf stp
                            
                            " Standard ML
                            au BufNewFile,BufRead *.sml			setf sml
                            
                            " Sratus VOS command macro
                            au BufNewFile,BufRead *.cm			setf voscm
                            
                            " Swift
                            au BufNewFile,BufRead *.swift			setf swift
                            au BufNewFile,BufRead *.swift.gyb		setf swiftgyb
                            
                            " Swift Intermediate Language or SILE
                            au BufNewFile,BufRead *.sil			call dist#ft#FTsil()
                            
                            " Sysctl
                            au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf	setf sysctl
                            
                            " Systemd unit files
                            au BufNewFile,BufRead */systemd/*.{automount,dnssd,link,mount,netdev,network,nspawn,path,service,slice,socket,swap,target,timer}	setf systemd
                            " Systemd overrides
                            au BufNewFile,BufRead */etc/systemd/*.conf.d/*.conf	setf systemd
                            au BufNewFile,BufRead */etc/systemd/system/*.d/*.conf	setf systemd
                            au BufNewFile,BufRead */.config/systemd/user/*.d/*.conf	setf systemd
                            " Systemd temp files
                            au BufNewFile,BufRead */etc/systemd/system/*.d/.#*	setf systemd
                            au BufNewFile,BufRead */etc/systemd/system/.#*		setf systemd
                            au BufNewFile,BufRead */.config/systemd/user/*.d/.#*	setf systemd
                            au BufNewFile,BufRead */.config/systemd/user/.#*	setf systemd
                            
                            " Synopsys Design Constraints
                            au BufNewFile,BufRead *.sdc			setf sdc
                            
                            " Sudoers
                            au BufNewFile,BufRead */etc/sudoers,sudoers.tmp	setf sudoers
                            
                            " SVG (Scalable Vector Graphics)
                            au BufNewFile,BufRead *.svg			setf svg
                            
                            " Surface
                            au BufRead,BufNewFile *.sface			setf surface
                            
                            " Tads (or Nroff or Perl test file)
                            au BufNewFile,BufRead *.t
                            	\ if !dist#ft#FTnroff() && !dist#ft#FTperl() | setf tads | endif
                            
                            " Tags
                            au BufNewFile,BufRead tags			setf tags
                            
                            " TAK
                            au BufNewFile,BufRead *.tak			setf tak
                            
                            " Task
                            au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
                            au BufRead,BufNewFile *.task			setf taskedit
                            
                            " Tcl (JACL too)
                            au BufNewFile,BufRead *.tcl,*.tm,*.tk,*.itcl,*.itk,*.jacl,.tclshrc,.wishrc	setf tcl
                            
                            " Teal
                            au BufRead,BufNewFile *.tl			setf teal
                            
                            " TealInfo
                            au BufNewFile,BufRead *.tli			setf tli
                            
                            " Telix Salt
                            au BufNewFile,BufRead *.slt			setf tsalt
                            
                            " Tera Term Language or Turtle
                            au BufRead,BufNewFile *.ttl
                            	\ if getline(1) =~ '^@\?\(prefix\|base\)' |
                            	\   setf turtle |
                            	\ else |
                            	\   setf teraterm |
                            	\ endif
                            
                            " Terminfo
                            au BufNewFile,BufRead *.ti			setf terminfo
                            
                            " Terraform variables
                            au BufRead,BufNewFile *.tfvars			setf terraform-vars
                            
                            " TeX
                            au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl	setf tex
                            au BufNewFile,BufRead *.tex			call dist#ft#FTtex()
                            
                            " ConTeXt
                            au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi,*.mkxl,*.mklx   setf context
                            
                            " Texinfo
                            au BufNewFile,BufRead *.texinfo,*.texi,*.txi	setf texinfo
                            
                            " TeX configuration
                            au BufNewFile,BufRead texmf.cnf			setf texmf
                            
                            " Tidy config
                            au BufNewFile,BufRead .tidyrc,tidyrc,tidy.conf	setf tidy
                            
                            " TF mud client
                            au BufNewFile,BufRead .tfrc,tfrc		setf tf
                            
                            " TF mud client or terraform
                            au BufNewFile,BufRead *.tf			call dist#ft#FTtf()
                            
                            " TLA+
                            au BufNewFile,BufRead *.tla			setf tla
                            
                            " tmux configuration
                            au BufNewFile,BufRead {.,}tmux*.conf		setf tmux
                            
                            " TOML
                            au BufNewFile,BufRead *.toml			setf toml
                            
                            " TPP - Text Presentation Program
                            au BufNewFile,BufRead *.tpp			setf tpp
                            
                            " Treetop
                            au BufRead,BufNewFile *.treetop			setf treetop
                            
                            " Trustees
                            au BufNewFile,BufRead trustees.conf		setf trustees
                            
                            " TSS - Geometry
                            au BufNewFile,BufReadPost *.tssgm		setf tssgm
                            
                            " TSS - Optics
                            au BufNewFile,BufReadPost *.tssop		setf tssop
                            
                            " TSS - Command Line (temporary)
                            au BufNewFile,BufReadPost *.tsscl		setf tsscl
                            
                            " TSV Files
                            au BufNewFile,BufRead *.tsv			setf tsv
                            
                            " Tutor mode
                            au BufNewFile,BufReadPost *.tutor		setf tutor
                            
                            " TWIG files
                            au BufNewFile,BufReadPost *.twig		setf twig
                            
                            " TypeScript or Qt translation file (which is XML)
                            au BufNewFile,BufReadPost *.ts
                            	\ if getline(1) =~ '<?xml' |
                            	\   setf xml |
                            	\ else |
                            	\   setf typescript |
                            	\ endif
                            
                            " TypeScript module and common
                            au BufNewFile,BufRead *.mts,*.cts		setf typescript
                            
                            " TypeScript with React
                            au BufNewFile,BufRead *.tsx			setf typescriptreact
                            
                            " Motif UIT/UIL files
                            au BufNewFile,BufRead *.uit,*.uil		setf uil
                            
                            " Udev conf
                            au BufNewFile,BufRead */etc/udev/udev.conf	setf udevconf
                            
                            " Udev permissions
                            au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
                            "
                            " Udev symlinks config
                            au BufNewFile,BufRead */etc/udev/cdsymlinks.conf	setf sh
                            
                            " UnrealScript
                            au BufNewFile,BufRead *.uc			setf uc
                            
                            " Updatedb
                            au BufNewFile,BufRead */etc/updatedb.conf	setf updatedb
                            
                            " Upstart (init(8)) config files
                            au BufNewFile,BufRead */usr/share/upstart/*.conf	       setf upstart
                            au BufNewFile,BufRead */usr/share/upstart/*.override	       setf upstart
                            au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
                            au BufNewFile,BufRead */.init/*.conf,*/.init/*.override	       setf upstart
                            au BufNewFile,BufRead */.config/upstart/*.conf		       setf upstart
                            au BufNewFile,BufRead */.config/upstart/*.override	       setf upstart
                            
                            " Vala
                            au BufNewFile,BufRead *.vala			setf vala
                            
                            " VDF
                            au BufNewFile,BufRead *.vdf			setf vdf
                            
                            " VDM
                            au BufRead,BufNewFile *.vdmpp,*.vpp		setf vdmpp
                            au BufRead,BufNewFile *.vdmrt			setf vdmrt
                            au BufRead,BufNewFile *.vdmsl,*.vdm		setf vdmsl
                            
                            " Vera
                            au BufNewFile,BufRead *.vr,*.vri,*.vrh		setf vera
                            
                            " Vagrant (uses Ruby syntax)
                            au BufNewFile,BufRead Vagrantfile		setf ruby
                            
                            " Verilog HDL
                            au BufNewFile,BufRead *.v			setf verilog
                            
                            " Verilog-AMS HDL
                            au BufNewFile,BufRead *.va,*.vams		setf verilogams
                            
                            " SystemVerilog
                            au BufNewFile,BufRead *.sv,*.svh		setf systemverilog
                            
                            " VHDL
                            au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst,*.vho  setf vhdl
                            
                            " Vim script
                            au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc	setf vim
                            
                            " Viminfo file
                            au BufNewFile,BufRead .viminfo,_viminfo		setf viminfo
                            
                            " Virata Config Script File or Drupal module
                            au BufRead,BufNewFile *.hw,*.module,*.pkg
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   setf virata |
                            	\ endif
                            
                            " Visual Basic (also uses *.bas) or FORM
                            au BufNewFile,BufRead *.frm			call dist#ft#FTfrm()
                            
                            " SaxBasic is close to Visual Basic
                            au BufNewFile,BufRead *.sba			setf vb
                            
                            " Vgrindefs file
                            au BufNewFile,BufRead vgrindefs			setf vgrindefs
                            
                            " VRML V1.0c
                            au BufNewFile,BufRead *.wrl			setf vrml
                            
                            " Vroom (vim testing and executable documentation)
                            au BufNewFile,BufRead *.vroom			setf vroom
                            
                            " Vue.js Single File Component
                            au BufNewFile,BufRead *.vue			setf vue
                            
                            " WebAssembly
                            au BufNewFile,BufRead *.wast,*.wat		setf wast
                            
                            " Webmacro
                            au BufNewFile,BufRead *.wm			setf webmacro
                            
                            " Wget config
                            au BufNewFile,BufRead .wgetrc,wgetrc		setf wget
                            
                            " Wget2 config
                            au BufNewFile,BufRead .wget2rc,wget2rc		setf wget2
                            
                            " Website MetaLanguage
                            au BufNewFile,BufRead *.wml			setf wml
                            
                            " Winbatch
                            au BufNewFile,BufRead *.wbt			setf winbatch
                            
                            " WSML
                            au BufNewFile,BufRead *.wsml			setf wsml
                            
                            " WPL
                            au BufNewFile,BufRead *.wpl			setf xml
                            
                            " WvDial
                            au BufNewFile,BufRead wvdial.conf,.wvdialrc	setf wvdial
                            
                            " CVS RC file
                            au BufNewFile,BufRead .cvsrc			setf cvsrc
                            
                            " CVS commit file
                            au BufNewFile,BufRead cvs\d\+			setf cvs
                            
                            " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
                            " lines in a WEB file).
                            au BufNewFile,BufRead *.web
                            	\ if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |
                            	\   setf web |
                            	\ else |
                            	\   setf winbatch |
                            	\ endif
                            
                            " Windows Scripting Host and Windows Script Component
                            au BufNewFile,BufRead *.ws[fc]			setf wsh
                            
                            " XHTML
                            au BufNewFile,BufRead *.xhtml,*.xht		setf xhtml
                            
                            " X Pixmap (dynamically sets colors, this used to trigger on BufEnter to make
                            " it work better, but that breaks setting 'filetype' manually)
                            au BufNewFile,BufRead *.xpm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ else |
                            	\   setf xpm |
                            	\ endif
                            au BufNewFile,BufRead *.xpm2			setf xpm2
                            
                            " XFree86 config
                            au BufNewFile,BufRead XF86Config
                            	\ if getline(1) =~ '\<XConfigurator\>' |
                            	\   let b:xf86conf_xfree86_version = 3 |
                            	\ endif |
                            	\ setf xf86conf
                            au BufNewFile,BufRead */xorg.conf.d/*.conf
                            	\ let b:xf86conf_xfree86_version = 4 |
                            	\ setf xf86conf
                            
                            " Xorg config
                            au BufNewFile,BufRead xorg.conf,xorg.conf-4	let b:xf86conf_xfree86_version = 4 | setf xf86conf
                            
                            " Xinetd conf
                            au BufNewFile,BufRead */etc/xinetd.conf		setf xinetd
                            
                            " XS Perl extension interface language
                            au BufNewFile,BufRead *.xs			setf xs
                            
                            " X resources file
                            au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
                            
                            " Xmath
                            au BufNewFile,BufRead *.msc,*.msf		setf xmath
                            au BufNewFile,BufRead *.ms
                            	\ if !dist#ft#FTnroff() | setf xmath | endif
                            
                            " XML  specific variants: docbk and xbl
                            au BufNewFile,BufRead *.xml			call dist#ft#FTxml()
                            
                            " XMI (holding UML models) is also XML
                            au BufNewFile,BufRead *.xmi			setf xml
                            
                            " CSPROJ files are Visual Studio.NET's XML-based C# project config files
                            au BufNewFile,BufRead *.csproj,*.csproj.user	setf xml
                            
                            " FSPROJ files are Visual Studio.NET's XML-based F# project config files
                            au BufNewFile,BufRead *.fsproj,*.fsproj.user	setf xml
                            
                            " VBPROJ files are Visual Studio.NET's XML-based Visual Basic project config files
                            au BufNewFile,BufRead *.vbproj,*.vbproj.user	setf xml
                            
                            " Qt Linguist translation source and Qt User Interface Files are XML
                            " However, for .ts TypeScript is more common.
                            au BufNewFile,BufRead *.ui			setf xml
                            
                            " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
                            au BufNewFile,BufRead *.tpm			setf xml
                            
                            " Xdg menus
                            au BufNewFile,BufRead */etc/xdg/menus/*.menu	setf xml
                            
                            " ATI graphics driver configuration
                            au BufNewFile,BufRead fglrxrc			setf xml
                            
                            " Web Services Description Language (WSDL)
                            au BufNewFile,BufRead *.wsdl			setf xml
                            
                            " XLIFF (XML Localisation Interchange File Format) is also XML
                            au BufNewFile,BufRead *.xlf			setf xml
                            au BufNewFile,BufRead *.xliff			setf xml
                            
                            " XML User Interface Language
                            au BufNewFile,BufRead *.xul			setf xml
                            
                            " X11 xmodmap (also see below)
                            au BufNewFile,BufRead *Xmodmap			setf xmodmap
                            
                            " Xquery
                            au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy	setf xquery
                            
                            " XSD
                            au BufNewFile,BufRead *.xsd			setf xsd
                            
                            " Xslt
                            au BufNewFile,BufRead *.xsl,*.xslt		setf xslt
                            
                            " Yacc
                            au BufNewFile,BufRead *.yy,*.yxx,*.y++		setf yacc
                            
                            " Yacc or racc
                            au BufNewFile,BufRead *.y			call dist#ft#FTy()
                            
                            " Yaml
                            au BufNewFile,BufRead *.yaml,*.yml		setf yaml
                            
                            " Raml
                            au BufNewFile,BufRead *.raml			setf raml
                            
                            " yum conf (close enough to dosini)
                            au BufNewFile,BufRead */etc/yum.conf		setf dosini
                            
                            " YANG
                            au BufRead,BufNewFile *.yang			setf yang
                            
                            " Zimbu
                            au BufNewFile,BufRead *.zu			setf zimbu
                            " Zimbu Templates
                            au BufNewFile,BufRead *.zut			setf zimbutempl
                            
                            " Zope
                            "   dtml (zope dynamic template markup language), pt (zope page template),
                            "   cpt (zope form controller page template)
                            au BufNewFile,BufRead *.dtml,*.pt,*.cpt		call dist#ft#FThtml()
                            "   zsql (zope sql method)
                            au BufNewFile,BufRead *.zsql			call dist#ft#SQL()
                            
                            " Z80 assembler asz80
                            au BufNewFile,BufRead *.z8a			setf z8a
                            
                            augroup END
                            
                            
                            " Source the user-specified filetype file, for backwards compatibility with
                            " Vim 5.x.
                            if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
                              execute "source " . myfiletypefile
                            endif
                            
                            
                            " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
                            " when there are no matching file name extensions.
                            " Don't do this for compressed files.
                            augroup filetypedetect
                            au BufNewFile,BufRead *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\ | runtime! scripts.vim | endif
                            au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
                            
                            
                            " Plain text files, needs to be far down to not override others.  This avoids
                            " the "conf" type being used if there is a line starting with '#'.
                            " But before patterns matching everything in a directory.
                            au BufNewFile,BufRead *.text,README,LICENSE,COPYING,AUTHORS	setf text
                            
                            
                            " Extra checks for when no filetype has been detected now.  Mostly used for
                            " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
                            " script file.
                            " Most of these should call s:StarSetf() to avoid names ending in .gz and the
                            " like are used.
                            
                            " More Apache style config files
                            au BufNewFile,BufRead */etc/proftpd/*.conf*,*/etc/proftpd/conf.*/*	call s:StarSetf('apachestyle')
                            au BufNewFile,BufRead proftpd.conf*					call s:StarSetf('apachestyle')
                            
                            " More Apache config files
                            au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*	call s:StarSetf('apache')
                            au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.*/*,*/etc/httpd/mods-*/*,*/etc/httpd/sites-*/*,*/etc/httpd/conf.d/*.conf*		call s:StarSetf('apache')
                            
                            " APT config file
                            au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} call s:StarSetf('aptconf')
                            
                            " Asterisk config file
                            au BufNewFile,BufRead *asterisk/*.conf*		call s:StarSetf('asterisk')
                            au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
                            
                            " Bazaar version control
                            au BufNewFile,BufRead bzr_log.*			setf bzr
                            
                            " Bazel build file
                            if !has("fname_case")
                              au BufNewFile,BufRead *.BUILD,BUILD		setf bzl
                            endif
                            
                            " BIND zone
                            au BufNewFile,BufRead */named/db.*,*/bind/db.*	call s:StarSetf('bindzone')
                            
                            au BufNewFile,BufRead cabal.project.*		call s:StarSetf('cabalproject')
                            
                            " Calendar
                            au BufNewFile,BufRead */.calendar/*,
                            	\*/share/calendar/*/calendar.*,*/share/calendar/calendar.*
                            	\					call s:StarSetf('calendar')
                            
                            " Changelog
                            au BufNewFile,BufRead [cC]hange[lL]og*
                            	\ if getline(1) =~ '; urgency='
                            	\|  call s:StarSetf('debchangelog')
                            	\|else
                            	\|  call s:StarSetf('changelog')
                            	\|endif
                            
                            " Crontab
                            au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*		call s:StarSetf('crontab')
                            
                            " dnsmasq(8) configuration
                            au BufNewFile,BufRead */etc/dnsmasq.d/*		call s:StarSetf('dnsmasq')
                            
                            " Dockerfile
                            au BufNewFile,BufRead Dockerfile.*,Containerfile.*	call s:StarSetf('dockerfile')
                            
                            " Dracula
                            au BufNewFile,BufRead drac.*			call s:StarSetf('dracula')
                            
                            " Fvwm
                            au BufNewFile,BufRead */.fvwm/*			call s:StarSetf('fvwm')
                            au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook
                            	\ let b:fvwm_version = 1 | call s:StarSetf('fvwm')
                            au BufNewFile,BufRead *fvwm2rc*
                            	\ if expand("<afile>:e") == "m4"
                            	\|  call s:StarSetf('fvwm2m4')
                            	\|else
                            	\|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')
                            	\|endif
                            
                            " Gedcom
                            au BufNewFile,BufRead */tmp/lltmp*		call s:StarSetf('gedcom')
                            
                            " Git
                            au BufNewFile,BufRead */.gitconfig.d/*,*/etc/gitconfig.d/*	call s:StarSetf('gitconfig')
                            
                            " Gitolite
                            au BufNewFile,BufRead */gitolite-admin/conf/*	call s:StarSetf('gitolite')
                            
                            " GTK RC
                            au BufNewFile,BufRead .gtkrc*,gtkrc*		call s:StarSetf('gtkrc')
                            
                            " Jam
                            au BufNewFile,BufRead Prl*.*,JAM*.*		call s:StarSetf('jam')
                            
                            " Jargon
                            au! BufNewFile,BufRead *jarg*
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'
                            	\|  call s:StarSetf('jargon')
                            	\|endif
                            
                            " Java Properties resource file (note: doesn't catch font.properties.pl)
                            au BufNewFile,BufRead *.properties_??_??_*	call s:StarSetf('jproperties')
                            
                            " Kconfig
                            au BufNewFile,BufRead Kconfig.*			call s:StarSetf('kconfig')
                            
                            " Lilo: Linux loader
                            au BufNewFile,BufRead lilo.conf*		call s:StarSetf('lilo')
                            
                            " Libsensors
                            au BufNewFile,BufRead */etc/sensors.d/[^.]*	call s:StarSetf('sensors')
                            
                            " Logcheck
                            au BufNewFile,BufRead */etc/logcheck/*.d*/*	call s:StarSetf('logcheck')
                            
                            " Makefile
                            au BufNewFile,BufRead [mM]akefile*		call s:StarSetf('make')
                            
                            " Ruby Makefile
                            au BufNewFile,BufRead [rR]akefile*		call s:StarSetf('ruby')
                            
                            " Mail (also matches muttrc.vim, so this is below the other checks)
                            au BufNewFile,BufRead {neo,}mutt[[:alnum:]._-]\\\{6\}	setf mail
                            
                            au BufNewFile,BufRead reportbug-*		call s:StarSetf('mail')
                            
                            " Modconf
                            au BufNewFile,BufRead */etc/modutils/*
                            	\ if executable(expand("<afile>")) != 1
                            	\|  call s:StarSetf('modconf')
                            	\|endif
                            au BufNewFile,BufRead */etc/modprobe.*		call s:StarSetf('modconf')
                            
                            " Mutt setup files (must be before catch *.rc)
                            au BufNewFile,BufRead */etc/Muttrc.d/*		call s:StarSetf('muttrc')
                            
                            " Mutt setup file
                            au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*	call s:StarSetf('muttrc')
                            au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*		call s:StarSetf('muttrc')
                            
                            " Neomutt setup file
                            au BufNewFile,BufRead .neomuttrc*,*/.neomutt/neomuttrc*	call s:StarSetf('neomuttrc')
                            au BufNewFile,BufRead neomuttrc*,Neomuttrc*		call s:StarSetf('neomuttrc')
                            
                            " Nroff macros
                            au BufNewFile,BufRead tmac.*			call s:StarSetf('nroff')
                            
                            " OpenBSD hostname.if
                            au BufNewFile,BufRead */etc/hostname.*		call s:StarSetf('config')
                            
                            " Pam conf
                            au BufNewFile,BufRead */etc/pam.d/*		call s:StarSetf('pamconf')
                            
                            " Printcap and Termcap
                            au BufNewFile,BufRead *printcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')
                            	\|endif
                            au BufNewFile,BufRead *termcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')
                            	\|endif
                            
                            " ReDIF
                            " Only used when the .rdf file was not detected to be XML.
                            au BufRead,BufNewFile *.rdf			call dist#ft#Redif()
                            
                            " Remind
                            au BufNewFile,BufRead .reminders*		call s:StarSetf('remind')
                            
                            " SGML catalog file
                            au BufNewFile,BufRead sgml.catalog*		call s:StarSetf('catalog')
                            
                            " avoid doc files being recognized a shell files
                            au BufNewFile,BufRead */doc/{,.}bash[_-]completion{,.d,.sh}{,/*} setf text
                            
                            " Shell scripts ending in a star
                            au BufNewFile,BufRead .bashrc*,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,bash-fc[-.]*,PKGBUILD*,APKBUILD*,*/{,.}bash[_-]completion{,.d,.sh}{,/*} call dist#ft#SetFileTypeSH("bash")
                            au BufNewFile,BufRead .kshrc* call dist#ft#SetFileTypeSH("ksh")
                            au BufNewFile,BufRead .profile* call dist#ft#SetFileTypeSH(getline(1))
                            
                            " Sudoers
                            au BufNewFile,BufRead */etc/sudoers.d/*		call s:StarSetf('sudoers')
                            
                            " tcsh scripts ending in a star
                            au BufNewFile,BufRead .tcshrc*	call dist#ft#SetFileTypeShell("tcsh")
                            
                            " csh scripts ending in a star
                            au BufNewFile,BufRead .login*,.cshrc*  call dist#ft#CSH()
                            
                            " tmux configuration with arbitrary extension
                            au BufNewFile,BufRead {.,}tmux*.conf*		setf tmux
                            
                            " VHDL
                            au BufNewFile,BufRead *.vhdl_[0-9]*		call s:StarSetf('vhdl')
                            
                            " Vim script
                            au BufNewFile,BufRead *vimrc*			call s:StarSetf('vim')
                            
                            " Subversion commit file
                            au BufNewFile,BufRead svn-commit*.tmp		setf svn
                            
                            " X resources file
                            au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
                            
                            " XFree86 config
                            au BufNewFile,BufRead XF86Config-4*
                            	\ let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
                            au BufNewFile,BufRead XF86Config*
                            	\ if getline(1) =~ '\<XConfigurator\>'
                            	\|  let b:xf86conf_xfree86_version = 3
                            	\|endif
                            	\|call s:StarSetf('xf86conf')
                            
                            " X11 xmodmap
                            au BufNewFile,BufRead *xmodmap*			call s:StarSetf('xmodmap')
                            
                            " Xinetd conf
                            au BufNewFile,BufRead */etc/xinetd.d/*		call s:StarSetf('xinetd')
                            
                            " yum conf (close enough to dosini)
                            au BufNewFile,BufRead */etc/yum.repos.d/*	call s:StarSetf('dosini')
                            
                            " Z-Shell script ending in a star
                            au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
                            au BufNewFile,BufRead zsh*,zlog*		call s:StarSetf('zsh')
                            
                            
                            " Help files match *.txt but should have a last line that is a modeline. 
                            au BufNewFile,BufRead *.txt
                                    \  if getline('$') !~ 'vim:.*ft=help'
                                    \|   setf text
                                    \| endif       
                            
                            " Blueprint markup files
                            au BufNewFile,BufRead *.blp			setf blueprint
                            
                            if !exists('g:did_load_ftdetect')
                              " Use the filetype detect plugins.  They may overrule any of the previously
                              " detected filetypes.
                              runtime! ftdetect/*.vim
                              runtime! ftdetect/*.lua
                            endif
                            
                            " NOTE: The above command could have ended the filetypedetect autocmd group
                            " and started another one. Let's make sure it has ended to get to a consistent
                            " state.
                            augroup END
                            
                            " Generic configuration file. Use FALLBACK, it's just guessing!
                            au filetypedetect BufNewFile,BufRead,StdinReadPost *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'
                            	\	|| getline(4) =~ '^#' || getline(5) =~ '^#') |
                            	\   setf FALLBACK conf |
                            	\ endif
                            
                            
                            " If the GUI is already running, may still need to install the Syntax menu.
                            " Don't do it when the 'M' flag is included in 'guioptions'.
                            if has("menu") && has("gui_running")
                                  \ && !exists("did_install_syntax_menu") && &guioptions !~# "M"
                              source <sfile>:p:h/menu.vim
                            endif
                            
                            " Function called for testing all functions defined here.  These are
                            " script-local, thus need to be executed here.
                            " Returns a string with error messages (hopefully empty).
                            func TestFiletypeFuncs(testlist)
                              let output = ''
                              for f in a:testlist
                                try
                                  exe f
                                catch
                                  let output = output . "\n" . f . ": " . v:exception
                                endtry
                              endfor
                              return output
                            endfunc
                            
                            " Restore 'cpoptions'
                            let &cpo = s:cpo_save
                            unlet s:cpo_save

SCRIPT  /usr/share/nvim/runtime/syntax/syntax.vim
Sourced 1 time
Total time:   0.000506
 Self time:   0.000221

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2022 Apr 12
                            
                            " This file is used for ":syntax on".
                            " It installs the autocommands and starts highlighting for all buffers.
                            
    1              0.000005 if !has("syntax")
                              finish
    1              0.000001 endif
                            
                            " If Syntax highlighting appears to be on already, turn it off first, so that
                            " any leftovers are cleared.
    1              0.000004 if exists("syntax_on") || exists("syntax_manual")
                              so <sfile>:p:h/nosyntax.vim
    1              0.000001 endif
                            
                            " Load the Syntax autocommands and set the default methods for highlighting.
    1   0.000283   0.000152 runtime syntax/synload.vim
                            
                            " Load the FileType autocommands if not done yet.
    1              0.000003 if exists("did_load_filetypes")
    1              0.000002   let s:did_ft = 1
                            else
                              filetype on
                              let s:did_ft = 0
    1              0.000001 endif
                            
                            " Set up the connection between FileType and Syntax autocommands.
                            " This makes the syntax automatically set when the file type is detected
                            " unless treesitter highlighting is enabled.
                            " Avoid an error when 'verbose' is set and <amatch> expansion fails.
    1              0.000002 augroup syntaxset
    1              0.000005   au! FileType *	if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
    1              0.000001 augroup END
                            
                            " Execute the syntax autocommands for the each buffer.
                            " If the filetype wasn't detected yet, do that now.
                            " Always do the syntaxset autocommands, for buffers where the 'filetype'
                            " already was set manually (e.g., help buffers).
    1   0.000172   0.000017 doautoall syntaxset FileType
    1              0.000002 if !s:did_ft
                              doautoall filetypedetect BufRead
    1              0.000002 endif

SCRIPT  /usr/share/nvim/runtime/syntax/synload.vim
Sourced 1 time
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2022 Apr 12
                            
                            " This file sets up for syntax highlighting.
                            " It is loaded from "syntax.vim" and "manual.vim".
                            " 1. Set the default highlight groups.
                            " 2. Install Syntax autocommands for all the available syntax files.
                            
    1              0.000002 if !has("syntax")
                              finish
    1              0.000001 endif
                            
                            " let others know that syntax has been switched on
    1              0.000005 let syntax_on = 1
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000010 let s:cpo_save = &cpo
    1              0.000011 set cpo&vim
                            
                            " First remove all old syntax autocommands.
    1              0.000003 au! Syntax
                            
    1              0.000004 au Syntax *		call s:SynSet()
                            
    1              0.000005 fun! s:SynSet()
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
                              syn clear
                              if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
                              0verbose let s = expand("<amatch>")
                              if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
                              if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
                                for name in split(s, '\.')
                                  if !empty(name)
                                    exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
                                    exe "runtime! syntax/" . name . ".lua syntax/" . name . "/*.lua"
                                  endif
                                endfor
                              endif
                            endfun
                            
                            
                            " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
    1              0.000019 au Syntax c,cpp,cs,idl,java,php,datascript
                            	\ if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)
                            	\	|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)
                            	\   | runtime! syntax/doxygen.vim
                            	\ | endif
                            
                            
                            " Source the user-specified syntax highlighting file
    1              0.000003 if exists("mysyntaxfile")
                              let s:fname = expand(mysyntaxfile)
                              if filereadable(s:fname)
                                execute "source " . fnameescape(s:fname)
                              endif
    1              0.000001 endif
                            
                            " Restore 'cpoptions'
    1              0.000010 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save

SCRIPT  /usr/share/nvim/runtime/plugin/gzip.vim
Sourced 1 time
Total time:   0.000211
 Self time:   0.000211

count  total (s)   self (s)
                            " Vim plugin for editing compressed files.
                            " Maintainer: Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2016 Oct 30
                            
                            " Exit quickly when:
                            " - this plugin was already loaded
                            " - when 'compatible' is set
                            " - some autocommands are already taking care of compressed files
    1              0.000010 if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
                              finish
    1              0.000001 endif
    1              0.000003 let loaded_gzip = 1
                            
    1              0.000002 augroup gzip
                              " Remove all gzip autocommands
    1              0.000005   au!
                            
                              " Enable editing of gzipped files.
                              " The functions are defined in autoload/gzip.vim.
                              "
                              " Set binary mode before reading the file.
                              " Use "gzip -d", gunzip isn't always available.
    1              0.000031   autocmd BufReadPre,FileReadPre	*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst,*.br,*.lzo setlocal bin
    1              0.000005   autocmd BufReadPost,FileReadPost	*.gz  call gzip#read("gzip -dn")
    1              0.000008   autocmd BufReadPost,FileReadPost	*.bz2 call gzip#read("bzip2 -d")
    1              0.000005   autocmd BufReadPost,FileReadPost	*.Z   call gzip#read("uncompress")
    1              0.000005   autocmd BufReadPost,FileReadPost	*.lzma call gzip#read("lzma -d")
    1              0.000004   autocmd BufReadPost,FileReadPost	*.xz  call gzip#read("xz -d")
    1              0.000005   autocmd BufReadPost,FileReadPost	*.lz  call gzip#read("lzip -d")
    1              0.000006   autocmd BufReadPost,FileReadPost	*.zst call gzip#read("zstd -d --rm")
    1              0.000004   autocmd BufReadPost,FileReadPost	*.br call gzip#read("brotli -d --rm")
    1              0.000004   autocmd BufReadPost,FileReadPost	*.lzo call gzip#read("lzop -d -U")
    1              0.000006   autocmd BufWritePost,FileWritePost	*.gz  call gzip#write("gzip")
    1              0.000004   autocmd BufWritePost,FileWritePost	*.bz2 call gzip#write("bzip2")
    1              0.000004   autocmd BufWritePost,FileWritePost	*.Z   call gzip#write("compress -f")
    1              0.000004   autocmd BufWritePost,FileWritePost	*.lzma call gzip#write("lzma -z")
    1              0.000005   autocmd BufWritePost,FileWritePost	*.xz  call gzip#write("xz -z")
    1              0.000004   autocmd BufWritePost,FileWritePost	*.lz  call gzip#write("lzip")
    1              0.000004   autocmd BufWritePost,FileWritePost	*.zst  call gzip#write("zstd --rm")
    1              0.000004   autocmd BufWritePost,FileWritePost	*.br  call gzip#write("brotli --rm")
    1              0.000007   autocmd BufWritePost,FileWritePost	*.lzo  call gzip#write("lzop -U")
    1              0.000005   autocmd FileAppendPre			*.gz  call gzip#appre("gzip -dn")
    1              0.000003   autocmd FileAppendPre			*.bz2 call gzip#appre("bzip2 -d")
    1              0.000003   autocmd FileAppendPre			*.Z   call gzip#appre("uncompress")
    1              0.000003   autocmd FileAppendPre			*.lzma call gzip#appre("lzma -d")
    1              0.000003   autocmd FileAppendPre			*.xz   call gzip#appre("xz -d")
    1              0.000002   autocmd FileAppendPre			*.lz   call gzip#appre("lzip -d")
    1              0.000003   autocmd FileAppendPre			*.zst call gzip#appre("zstd -d --rm")
    1              0.000003   autocmd FileAppendPre			*.br call gzip#appre("brotli -d --rm")
    1              0.000004   autocmd FileAppendPre			*.lzo call gzip#appre("lzop -d -U")
    1              0.000003   autocmd FileAppendPost		*.gz  call gzip#write("gzip")
    1              0.000003   autocmd FileAppendPost		*.bz2 call gzip#write("bzip2")
    1              0.000003   autocmd FileAppendPost		*.Z   call gzip#write("compress -f")
    1              0.000003   autocmd FileAppendPost		*.lzma call gzip#write("lzma -z")
    1              0.000002   autocmd FileAppendPost		*.xz call gzip#write("xz -z")
    1              0.000003   autocmd FileAppendPost		*.lz call gzip#write("lzip")
    1              0.000003   autocmd FileAppendPost		*.zst call gzip#write("zstd --rm")
    1              0.000004   autocmd FileAppendPost		*.br call gzip#write("brotli --rm")
    1              0.000002   autocmd FileAppendPost		*.lzo call gzip#write("lzop -U")
    1              0.000002 augroup END

SCRIPT  /usr/share/nvim/runtime/plugin/health.vim
Sourced 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000006 autocmd CmdUndefined CheckHealth checkhealth

SCRIPT  /usr/share/nvim/runtime/plugin/matchit.vim
Sourced 1 time
Total time:   0.000635
 Self time:   0.000393

count  total (s)   self (s)
                            " Nvim: load the matchit plugin by default.
    1              0.000009 if !exists("g:loaded_matchit") && stridx(&packpath, $VIMRUNTIME) >= 0
    1   0.000620   0.000378   packadd matchit
    1              0.000002 endif

SCRIPT  /usr/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim
Sourced 1 time
Total time:   0.000233
 Self time:   0.000233

count  total (s)   self (s)
                            "  matchit.vim: (global plugin) Extended "%" matching
                            "  Maintainer:  Christian Brabandt
                            "  Version:     1.18
                            "  Last Change: 2020 Dec 23
                            "  Repository:  https://github.com/chrisbra/matchit
                            "  Previous URL:http://www.vim.org/script.php?script_id=39
                            "  Previous Maintainer:  Benji Fisher PhD   <benji@member.AMS.org>
                            
                            " Documentation:
                            "  The documentation is in a separate file: ../doc/matchit.txt
                            
                            " Credits:
                            "  Vim editor by Bram Moolenaar (Thanks, Bram!)
                            "  Original script and design by Raul Segura Acevedo
                            "  Support for comments by Douglas Potts
                            "  Support for back references and other improvements by Benji Fisher
                            "  Support for many languages by Johannes Zellner
                            "  Suggestions for improvement, bug reports, and support for additional
                            "  languages by Jordi-Albert Batalla, Neil Bird, Servatius Brandt, Mark
                            "  Collett, Stephen Wall, Dany St-Amant, Yuheng Xie, and Johannes Zellner.
                            
                            " Debugging:
                            "  If you'd like to try the built-in debugging commands...
                            "   :MatchDebug      to activate debugging for the current buffer
                            "  This saves the values of several key script variables as buffer-local
                            "  variables.  See the MatchDebug() function, below, for details.
                            
                            " TODO:  I should think about multi-line patterns for b:match_words.
                            "   This would require an option:  how many lines to scan (default 1).
                            "   This would be useful for Python, maybe also for *ML.
                            " TODO:  Maybe I should add a menu so that people will actually use some of
                            "   the features that I have implemented.
                            " TODO:  Eliminate the MultiMatch function.  Add yet another argument to
                            "   Match_wrapper() instead.
                            " TODO:  Allow :let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
                            " TODO:  Make backrefs safer by using '\V' (very no-magic).
                            " TODO:  Add a level of indirection, so that custom % scripts can use my
                            "   work but extend it.
                            
                            " Allow user to prevent loading and prevent duplicate loading.
    1              0.000008 if exists("g:loaded_matchit") || &cp
                              finish
    1              0.000001 endif
    1              0.000003 let g:loaded_matchit = 1
                            
    1              0.000006 let s:save_cpo = &cpo
    1              0.000007 set cpo&vim
                            
    1              0.000015 nnoremap <silent> <Plug>(MatchitNormalForward)     :<C-U>call matchit#Match_wrapper('',1,'n')<CR>
    1              0.000008 nnoremap <silent> <Plug>(MatchitNormalBackward)    :<C-U>call matchit#Match_wrapper('',0,'n')<CR>
    1              0.000012 xnoremap <silent> <Plug>(MatchitVisualForward)     :<C-U>call matchit#Match_wrapper('',1,'v')<CR>
                                  \:if col("''") != col("$") \| exe ":normal! m'" \| endif<cr>gv``
    1              0.000007 xnoremap <silent> <Plug>(MatchitVisualBackward)    :<C-U>call matchit#Match_wrapper('',0,'v')<CR>m'gv``
    1              0.000007 onoremap <silent> <Plug>(MatchitOperationForward)  :<C-U>call matchit#Match_wrapper('',1,'o')<CR>
    1              0.000006 onoremap <silent> <Plug>(MatchitOperationBackward) :<C-U>call matchit#Match_wrapper('',0,'o')<CR>
                            
                            " Analogues of [{ and ]} using matching patterns:
    1              0.000006 nnoremap <silent> <Plug>(MatchitNormalMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>
    1              0.000006 nnoremap <silent> <Plug>(MatchitNormalMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>
    1              0.000006 xnoremap <silent> <Plug>(MatchitVisualMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>m'gv``
    1              0.000006 xnoremap <silent> <Plug>(MatchitVisualMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>m'gv``
    1              0.000006 onoremap <silent> <Plug>(MatchitOperationMultiBackward) :<C-U>call matchit#MultiMatch("bW", "o")<CR>
    1              0.000006 onoremap <silent> <Plug>(MatchitOperationMultiForward)  :<C-U>call matchit#MultiMatch("W",  "o")<CR>
                            
                            " text object:
    1              0.000008 xmap <silent> <Plug>(MatchitVisualTextObject) <Plug>(MatchitVisualMultiBackward)o<Plug>(MatchitVisualMultiForward)
                            
    1              0.000003 if !exists("g:no_plugin_maps")
    1              0.000004   nmap <silent> %  <Plug>(MatchitNormalForward)
    1              0.000007   nmap <silent> g% <Plug>(MatchitNormalBackward)
    1              0.000003   xmap <silent> %  <Plug>(MatchitVisualForward)
    1              0.000003   xmap <silent> g% <Plug>(MatchitVisualBackward)
    1              0.000004   omap <silent> %  <Plug>(MatchitOperationForward)
    1              0.000004   omap <silent> g% <Plug>(MatchitOperationBackward)
                            
                              " Analogues of [{ and ]} using matching patterns:
    1              0.000004   nmap <silent> [% <Plug>(MatchitNormalMultiBackward)
    1              0.000006   nmap <silent> ]% <Plug>(MatchitNormalMultiForward)
    1              0.000003   xmap <silent> [% <Plug>(MatchitVisualMultiBackward)
    1              0.000004   xmap <silent> ]% <Plug>(MatchitVisualMultiForward)
    1              0.000003   omap <silent> [% <Plug>(MatchitOperationMultiBackward)
    1              0.000004   omap <silent> ]% <Plug>(MatchitOperationMultiForward)
                            
                              " Text object
    1              0.000004   xmap a% <Plug>(MatchitVisualTextObject)
    1              0.000001 endif
                            
                            " Call this function to turn on debugging information.  Every time the main
                            " script is run, buffer variables will be saved.  These can be used directly
                            " or viewed using the menu items below.
    1              0.000004 if !exists(":MatchDebug")
    1              0.000005   command! -nargs=0 MatchDebug call matchit#Match_debug()
    1              0.000001 endif
                            
    1              0.000010 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim:sts=2:sw=2:et:

SCRIPT  /usr/share/nvim/runtime/plugin/matchparen.vim
Sourced 1 time
Total time:   0.000197
 Self time:   0.000197

count  total (s)   self (s)
                            " Vim plugin for showing matching parens
                            " Maintainer:  Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2021 Apr 08
                            
                            " Exit quickly when:
                            " - this plugin was already loaded (or disabled)
                            " - when 'compatible' is set
    1              0.000008 if exists("g:loaded_matchparen") || &cp
                              finish
    1              0.000001 endif
    1              0.000002 let g:loaded_matchparen = 1
                            
    1              0.000002 if !exists("g:matchparen_timeout")
    1              0.000002   let g:matchparen_timeout = 300
    1              0.000001 endif
    1              0.000003 if !exists("g:matchparen_insert_timeout")
    1              0.000002   let g:matchparen_insert_timeout = 60
    1              0.000001 endif
                            
    1              0.000002 augroup matchparen
                              " Replace all matchparen autocommands
    1              0.000012   autocmd! CursorMoved,CursorMovedI,WinEnter,WinScrolled * call s:Highlight_Matching_Pair()
    1              0.000004   autocmd! WinLeave * call s:Remove_Matches()
    1              0.000003   if exists('##TextChanged')
    1              0.000007     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
    1              0.000001   endif
    1              0.000001 augroup END
                            
                            " Skip the rest if it was already done.
    1              0.000004 if exists("*s:Highlight_Matching_Pair")
                              finish
    1              0.000001 endif
                            
    1              0.000005 let s:cpo_save = &cpo
    1              0.000006 set cpo-=C
                            
                            " The function that is invoked (very often) to define a ":match" highlighting
                            " for any matching paren.
    1              0.000003 func s:Highlight_Matching_Pair()
                              " Remove any previous match.
                              call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
                              if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
                              let c_lnum = line('.')
                              let c_col = col('.')
                              let before = 0
                            
                              let text = getline(c_lnum)
                              let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
                              if empty(matches)
                                let [c_before, c] = ['', '']
                              else
                                let [c_before, c] = matches[1:2]
                              endif
                              let plist = split(&matchpairs, '.\zs[:,]')
                              let i = index(plist, c)
                              if i < 0
                                " not found, in Insert mode try character before the cursor
                                if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
                                if i < 0
                                  " not found, nothing to do
                                  return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' .
                            	\ '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) .
                            	    \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif
                            endfunction
                            
    1              0.000002 func s:Remove_Matches()
                              if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            endfunc
                            
                            
                            " Define commands that will disable and enable the plugin.
    1              0.000003 command DoMatchParen call s:DoMatchParen()
    1              0.000002 command NoMatchParen call s:NoMatchParen()
                            
    1              0.000002 func s:NoMatchParen()
                              let w = winnr()
                              noau windo silent! call matchdelete(3)
                              unlet! g:loaded_matchparen
                              exe "noau ". w . "wincmd w"
                              au! matchparen
                            endfunc
                            
    1              0.000001 func s:DoMatchParen()
                              runtime plugin/matchparen.vim
                              let w = winnr()
                              silent windo doau CursorMoved
                              exe "noau ". w . "wincmd w"
                            endfunc
                            
    1              0.000009 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save

SCRIPT  /usr/share/nvim/runtime/plugin/netrwPlugin.vim
Sourced 1 time
Total time:   0.000449
 Self time:   0.000449

count  total (s)   self (s)
                            " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
                            "            PLUGIN SECTION
                            " Date:		Feb 09, 2021
                            " Maintainer:	Charles E Campbell <NcampObell@SdrPchip.AorgM-NOSPAM>
                            " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
                            " Copyright:    Copyright (C) 1999-2021 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
                            "               *as is* and comes with no warranty of any kind, either
                            "               expressed or implied. By using this plugin, you agree that
                            "               in no event will the copyright holder be liable for any damages
                            "               resulting from the use of this software.
                            "
                            "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
                            "  (James 1:22 RSV)
                            " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                            " Load Once: {{{1
    1              0.000007 if &cp || exists("g:loaded_netrwPlugin")
                             finish
    1              0.000001 endif
    1              0.000002 let g:loaded_netrwPlugin = "v171"
    1              0.000005 let s:keepcpo = &cpo
    1              0.000005 set cpo&vim
                            "DechoRemOn
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
                            
                            " Local Browsing Autocmds: {{{2
    1              0.000002 augroup FileExplorer
    1              0.000005  au!
    1              0.000004  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
    1              0.000003  au BufEnter *	sil call s:LocalBrowse(expand("<amatch>"))
    1              0.000006  au VimEnter *	sil call s:VimEnter(expand("<amatch>"))
    1              0.000010  if has("win32") || has("win95") || has("win64") || has("win16")
                              au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
    1              0.000001  endif
    1              0.000001 augroup END
                            
                            " Network Browsing Reading Writing: {{{2
    1              0.000001 augroup Network
    1              0.000004  au!
    1              0.000008  au BufReadCmd   file://*											call netrw#FileUrlEdit(expand("<amatch>"))
    1              0.000018  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
    1              0.000019  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
    1              0.000024  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
    1              0.000018  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
    1              0.000002  try
    1              0.000022   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
                             catch /^Vim\%((\a\+)\)\=:E216/
                              au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
    1              0.000002  endtry
    1              0.000001 augroup END
                            
                            " Commands: :Nread, :Nwrite, :NetUserPass {{{2
    1              0.000011 com! -count=1 -nargs=*	Nread		let s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
    1              0.000009 com! -range=% -nargs=*	Nwrite		let s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
    1              0.000003 com! -nargs=*		NetUserPass	call NetUserPass(<f-args>)
    1              0.000007 com! -nargs=*	        Nsource		let s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
    1              0.000003 com! -nargs=?		Ntree		call netrw#SetTreetop(1,<q-args>)
                            
                            " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
    1              0.000009 com! -nargs=* -bar -bang -count=0 -complete=dir	Explore		call netrw#Explore(<count>,0,0+<bang>0,<q-args>)
    1              0.000007 com! -nargs=* -bar -bang -count=0 -complete=dir	Sexplore	call netrw#Explore(<count>,1,0+<bang>0,<q-args>)
    1              0.000005 com! -nargs=* -bar -bang -count=0 -complete=dir	Hexplore	call netrw#Explore(<count>,1,2+<bang>0,<q-args>)
    1              0.000006 com! -nargs=* -bar -bang -count=0 -complete=dir	Vexplore	call netrw#Explore(<count>,1,4+<bang>0,<q-args>)
    1              0.000005 com! -nargs=* -bar       -count=0 -complete=dir	Texplore	call netrw#Explore(<count>,0,6        ,<q-args>)
    1              0.000003 com! -nargs=* -bar -bang			Nexplore	call netrw#Explore(-1,0,0,<q-args>)
    1              0.000003 com! -nargs=* -bar -bang			Pexplore	call netrw#Explore(-2,0,0,<q-args>)
    1              0.000005 com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore	call netrw#Lexplore(<count>,<bang>0,<q-args>)
                            
                            " Commands: NetrwSettings {{{2
    1              0.000003 com! -nargs=0	NetrwSettings	call netrwSettings#NetrwSettings()
    1              0.000003 com! -bang	NetrwClean	call netrw#Clean(<bang>0)
                            
                            " Maps:
    1              0.000003 if !exists("g:netrw_nogx")
    1              0.000011  if maparg('gx','n') == ""
    1              0.000014   if !hasmapto('<Plug>NetrwBrowseX')
    1              0.000005    nmap <unique> gx <Plug>NetrwBrowseX
    1              0.000001   endif
    1              0.000008   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(netrw#GX(),netrw#CheckIfRemote(netrw#GX()))<cr>
    1              0.000001  endif
    1              0.000006  if maparg('gx','x') == ""
    1              0.000008   if !hasmapto('<Plug>NetrwBrowseXVis')
    1              0.000004    xmap <unique> gx <Plug>NetrwBrowseXVis
    1              0.000001   endif
    1              0.000006   xno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
    1              0.000001  endif
    1              0.000001 endif
    1              0.000003 if exists("g:netrw_usetab") && g:netrw_usetab
                             if maparg('<c-tab>','n') == ""
                              nmap <unique> <c-tab> <Plug>NetrwShrink
                             endif
                             nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
    1              0.000001 endif
                            
                            " ---------------------------------------------------------------------
                            " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
    1              0.000003 fun! s:LocalBrowse(dirname)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
                              if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
                              if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               " Jul 13, 2021: for whatever reason, preceding the following call with
                               " a   sil!  causes an unbalanced if-endif vim error
                               call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
                              endif
                            
                            "  call Dret("s:LocalBrowse")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
                            "             Its purpose: to look over all windows and run s:LocalBrowse() on
                            "             them, which checks if they're directories and will create a directory
                            "             listing when appropriate.
                            "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
                            "             has already been called.
    1              0.000002 fun! s:VimEnter(dirname)
                            "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
                              if has('nvim') || v:version < 802
                              " Johann Hchtl: reported that the call range... line causes an E488: Trailing characters
                              "                error with neovim. I suspect its because neovim hasn't updated with recent
                              "                vim patches. As is, this code will have problems with popup terminals
                              "                instantiated before the VimEnter event runs.
                              " Ingo Karkat  : E488 also in Vim 8.1.1602
                              let curwin       = winnr()
                              let s:vimentered = 1
                              windo call s:LocalBrowse(expand("%:p"))
                              exe curwin."wincmd w"
                             else
                              " the following complicated expression comes courtesy of lacygoill; largely does the same thing as the windo and 
                              " wincmd which are commented out, but avoids some side effects. Allows popup terminal before VimEnter.
                              let s:vimentered = 1
                              call range(1, winnr('$'))->map({_, v -> win_execute(win_getid(v), 'call expand("%:p")->s:LocalBrowse()')})
                             endif
                            "  call Dret("s:VimEnter")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " NetrwStatusLine: {{{1
    1              0.000001 fun! NetrwStatusLine()
                            "  let g:stlmsg= "Xbufnr=".w:netrw_explore_bufnr." bufnr=".bufnr("%")." Xline#".w:netrw_explore_line." line#".line(".")
                              if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
                               let &stl= s:netrw_explore_stl
                               if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
                               if exists("w:netrw_explore_line")|unlet w:netrw_explore_line|endif
                               return ""
                              else
                               return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
                              endif
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " NetUserPass: set username and password for subsequent ftp transfer {{{1
                            "   Usage:  :call NetUserPass()			-- will prompt for userid and password
                            "	    :call NetUserPass("uid")		-- will prompt for password
                            "	    :call NetUserPass("uid","password") -- sets global userid and password
    1              0.000001 fun! NetUserPass(...)
                            
                             " get/set userid
                             if a:0 == 0
                            "  call Dfunc("NetUserPass(a:0<".a:0.">)")
                              if !exists("g:netrw_uid") || g:netrw_uid == ""
                               " via prompt
                               let g:netrw_uid= input('Enter username: ')
                              endif
                             else	" from command line
                            "  call Dfunc("NetUserPass(a:1<".a:1.">) {")
                              let g:netrw_uid= a:1
                             endif
                            
                             " get password
                             if a:0 <= 1 " via prompt
                            "  call Decho("a:0=".a:0." case <=1:")
                              let g:netrw_passwd= inputsecret("Enter Password: ")
                             else " from command line
                            "  call Decho("a:0=".a:0." case >1: a:2<".a:2.">")
                              let g:netrw_passwd=a:2
                             endif
                            "  call Dret("NetUserPass")
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " Modelines And Restoration: {{{1
    1              0.000010 let &cpo= s:keepcpo
    1              0.000002 unlet s:keepcpo
                            " vim:ts=8 fdm=marker

SCRIPT  /usr/share/nvim/runtime/plugin/rplugin.vim
Sourced 1 time
Total time:   0.000207
 Self time:   0.000074

count  total (s)   self (s)
    1              0.000004 if exists('g:loaded_remote_plugins')
                              finish
    1              0.000001 endif
    1              0.000003 let g:loaded_remote_plugins = '/path/to/manifest'
                            
                            " Get the path to the rplugin manifest file.
    1              0.000002 function! s:GetManifestPath() abort
                              let manifest_base = ''
                            
                              if exists('$NVIM_RPLUGIN_MANIFEST')
                                return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
                              endif
                            
                              let dest = stdpath('data')
                              if !empty(dest)
                                if !isdirectory(dest)
                                  call mkdir(dest, 'p', 0700)
                                endif
                                let manifest_base = dest
                              endif
                            
                              return manifest_base.'/rplugin.vim'
                            endfunction
                            
                            " Old manifest file based on known script locations.
    1              0.000002 function! s:GetOldManifestPaths() abort
                              let prefix = exists('$MYVIMRC')
                                    \ ? $MYVIMRC
                                    \ : matchstr(get(split(execute('scriptnames'), '\n'), 0, ''), '\f\+$')
                              let origpath = fnamemodify(expand(prefix, 1), ':h')
                                    \.'/.'.fnamemodify(prefix, ':t').'-rplugin~'
                              if !has('win32')
                                return [origpath]
                              endif
                              " Windows used to use $APPLOCALDATA/nvim but stdpath('data') is
                              " $XDG_DATA_DIR/nvim-data
                              let pseudostdpath = exists('$LOCALAPPDATA') ? '$LOCALAPPDATA' : '~/AppData/Local'
                              let pseudostdpath = fnamemodify(expand(pseudostdpath), ':p')
                              return [substitute(pseudostdpath, '[/\\]\=$', '/', '') . 'nvim/rplugin.vim', origpath]
                            endfunction
                            
    1              0.000001 function! s:GetManifest() abort
                              let manifest = s:GetManifestPath()
                              if !filereadable(manifest)
                                " Check if an old manifest file exists and move it to the new location.
                                for old_manifest in s:GetOldManifestPaths()
                                  if filereadable(old_manifest)
                                    call rename(old_manifest, manifest)
                                    break
                                  endif
                                endfor
                              endif
                              return manifest
                            endfunction
                            
    1              0.000001 function! s:LoadRemotePlugins() abort
                              let g:loaded_remote_plugins = s:GetManifest()
                              if filereadable(g:loaded_remote_plugins)
                                execute 'source' fnameescape(g:loaded_remote_plugins)
                              endif
                            endfunction
                            
    1              0.000004 command! -bar UpdateRemotePlugins call remote#host#UpdateRemotePlugins()
                            
    1              0.000007 if index(v:argv, "--clean") < 0
    1   0.000144   0.000012   call s:LoadRemotePlugins()
    1              0.000001 endif

SCRIPT  /home/benk/.local/share/nvim/rplugin.vim
Sourced 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
                            " perl plugins
                            
                            
                            " node plugins
                            
                            
                            " python3 plugins
                            
                            
                            " ruby plugins
                            
                            
                            " python plugins
                            
                            

SCRIPT  /usr/share/nvim/runtime/plugin/shada.vim
Sourced 1 time
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    1              0.000004 if exists('g:loaded_shada_plugin')
                              finish
    1              0.000001 endif
    1              0.000002 let g:loaded_shada_plugin = 1
                            
    1              0.000002 augroup ShaDaCommands
    1              0.000005   autocmd!
    1              0.000013   autocmd BufReadCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call setline('.', shada#get_strings(readfile(expand('<afile>'),'b')))
                                    \ |setlocal filetype=shada
    1              0.000009   autocmd FileReadCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call append("'[", shada#get_strings(readfile(expand('<afile>'), 'b')))
    1              0.000009   autocmd BufWriteCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |if writefile(shada#get_binstrings(getline(1, '$')),
                                                   \expand('<afile>'), 'b') == 0
                                    \ |  let &l:modified = (expand('<afile>') is# bufname(+expand('<abuf>'))
                                                           \? 0
                                                           \: stridx(&cpoptions, '+') != -1)
                                    \ |endif
    1              0.000009   autocmd FileWriteCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call writefile(
                                          \shada#get_binstrings(getline(min([line("'["), line("']")]),
                                                                       \max([line("'["), line("']")]))),
                                          \expand('<afile>'),
                                          \'b')
    1              0.000008   autocmd FileAppendCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call writefile(
                                          \shada#get_binstrings(getline(min([line("'["), line("']")]),
                                                                       \max([line("'["), line("']")]))),
                                          \expand('<afile>'),
                                          \'ab')
    1              0.000006   autocmd SourceCmd *.shada,*.shada.tmp.[a-z]
                                    \ :execute 'rshada' fnameescape(expand('<afile>'))
    1              0.000001 augroup END

SCRIPT  /usr/share/nvim/runtime/plugin/spellfile.vim
Sourced 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
                            " Vim plugin for downloading spell files
                            
    1              0.000011 if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
                              finish
    1              0.000001 endif
    1              0.000002 let loaded_spellfile_plugin = 1
                            
    1              0.000005 autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))

SCRIPT  /usr/share/nvim/runtime/plugin/tarPlugin.vim
Sourced 1 time
Total time:   0.000134
 Self time:   0.000134

count  total (s)   self (s)
                            " tarPlugin.vim -- a Vim plugin for browsing tarfiles
                            " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
                            " Modified by Charles E. Campbell
                            " Distributed under the GNU General Public License.
                            "
                            " Updates are available from <http://michael.toren.net/code/>.  If you
                            " find this script useful, or have suggestions for improvements, please
                            " let me know.
                            " Also look there for further comments and documentation.
                            "
                            " This part only sets the autocommands.  The functions are in autoload/tar.vim.
                            " ---------------------------------------------------------------------
                            "  Load Once: {{{1
    1              0.000006 if &cp || exists("g:loaded_tarPlugin")
                             finish
    1              0.000001 endif
    1              0.000002 let g:loaded_tarPlugin = "v32"
    1              0.000005 let s:keepcpo          = &cpo
    1              0.000006 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            "  Public Interface: {{{1
    1              0.000001 augroup tar
    1              0.000004   au!
    1              0.000007   au BufReadCmd   tarfile::*	call tar#Read(expand("<amatch>"), 1)
    1              0.000004   au FileReadCmd  tarfile::*	call tar#Read(expand("<amatch>"), 0)
    1              0.000004   au BufWriteCmd  tarfile::*	call tar#Write(expand("<amatch>"))
    1              0.000004   au FileWriteCmd tarfile::*	call tar#Write(expand("<amatch>"))
                            
    1              0.000003   if has("unix")
    1              0.000004    au BufReadCmd   tarfile::*/*	call tar#Read(expand("<amatch>"), 1)
    1              0.000004    au FileReadCmd  tarfile::*/*	call tar#Read(expand("<amatch>"), 0)
    1              0.000003    au BufWriteCmd  tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000003    au FileWriteCmd tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000001   endif
                            
    1              0.000004   au BufReadCmd   *.tar.gz		call tar#Browse(expand("<amatch>"))
    1              0.000004   au BufReadCmd   *.tar			call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.lrp			call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tar.bz2		call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tar.Z		call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tbz			call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tgz			call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tar.lzma	call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tar.xz		call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.txz			call tar#Browse(expand("<amatch>"))
    1              0.000005   au BufReadCmd   *.tar.zst		call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tzs			call tar#Browse(expand("<amatch>"))
    1              0.000001 augroup END
    1              0.000004 com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
                            
                            " ---------------------------------------------------------------------
                            " Restoration And Modelines: {{{1
                            " vim: fdm=marker
    1              0.000009 let &cpo= s:keepcpo
    1              0.000003 unlet s:keepcpo

SCRIPT  /usr/share/nvim/runtime/plugin/tohtml.vim
Sourced 1 time
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
                            " Vim plugin for converting a syntax highlighted file to HTML.
                            " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
                            " Last Change: 2019 Nov 13
                            "
                            " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
                            " $VIMRUNTIME/syntax/2html.vim
                            "
    1              0.000003 if exists('g:loaded_2html_plugin')
                              finish
    1              0.000001 endif
    1              0.000002 let g:loaded_2html_plugin = 'vim8.1_v2'
                            
                            "
                            " Changelog: {{{
                            "   8.1_v2  (this version): - Fix Bitbucket issue #19: fix calculation of tab
                            "                             stop position to use in expanding a tab, when that
                            "                             tab occurs after a syntax match which in turn
                            "                             comes after previously expanded tabs.
                            "                           - Set eventignore while splitting a window for the
                            "                             destination file to ignore FileType events;
                            "                             speeds up processing when the destination file
                            "                             already exists and HTML highlight takes too long.
                            "                           - Fix Bitbucket issue #20: progress bar could not be
                            "                             seen when DiffDelete background color matched
                            "                             StatusLine background color. Added TOhtmlProgress
                            "                             highlight group for manual user override, but
                            "                             calculate it to be visible compared to StatusLine
                            "                             by default.
                            "                           - Fix Bitbucket issue #1: Remove workaround for old
                            "                             browsers which don't support 'ch' CSS unit, since
                            "                             all modern browsers, including IE>=9, support it.
                            "                           - Fix Bitbucket issue #10: support termguicolors
                            "                           - Fix Bitbucket issue #21: default to using
                            "                             generated content instead of <input> tags for
                            "                             uncopyable text, so that text is correctly
                            "                             prevented from being copied in chrome. Use
                            "                             g:html_use_input_for_pc option to control the
                            "                             method used.
                            "                           - Switch to HTML5 to allow using vnu as a validator
                            "                             in unit test.
                            "                           - Fix fallback sizing of <input> tags for browsers
                            "                             without "ch" support.
                            "                           - Fix cursor on unselectable diff filler text.
                            "   8.1_v1  (Vim 8.1.0528): - Fix Bitbucket issue #6: Don't generate empty
                            "                             script tag.
                            "                           - Fix Bitbucket issue #5: javascript should
                            "                             declare variables with "var".
                            "                           - Fix Bitbucket issue #13: errors thrown sourcing
                            "                             2html.vim directly when plugins not loaded.
                            "                           - Fix Bitbucket issue #16: support 'vartabstop'.
                            "
                            "   7.4 updates: {{{
                            "   7.4_v2  (Vim 7.4.0899): Fix error raised when converting a diff containing
                            "                           an empty buffer. Jan Stocker: allow g:html_font to
                            "                           take a list so it is easier to specfiy fallback
                            "                           fonts in the generated CSS.
                            "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and
                            "			    also for version-specific modelines like "vim>703:".
                            "}}}
                            "
                            "   7.3 updates: {{{
                            "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using
                            "			    g:html_line_ids=0. Allow customizing
                            "			    important IDs (like line IDs and fold IDs) using
                            "			    g:html_id_expr evaluated when the buffer conversion
                            "			    is started.
                            "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and
                            "			    insert modeline to set it to manual.
                            "			    Fix bug: diff mode with 2 unsaved buffers creates a
                            "			    duplicate of one buffer instead of including both.
                            "			    Add anchors to each line so you can put '#L123'
                            "			    or '#123' at the end of the URL to jump to line 123
                            "			    (idea by Andy Spencer). Add javascript to open folds
                            "			    to show the anchor being jumped to if it is hidden.
                            "			    Fix XML validation error: &nsbp; not part of XML.
                            "			    Allow TOhtml to chain together with other commands
                            "			    using |.
                            "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple
                            "			    highlight groups make up the start-of-modeline text.
                            "			    Improve render time of page with uncopyable regions
                            "			    by not using one-input-per-char. Change name of
                            "			    uncopyable option from html_unselectable to
                            "			    html_prevent_copy. Added html_no_invalid option and
                            "			    default to inserting invalid markup for uncopyable
                            "			    regions to prevent MS Word from pasting undeletable
                            "			    <input> elements. Fix 'cpo' handling (Thilo Six).
                            "		 7.3_v12b1: Add html_unselectable option. Rework logic to
                            "			    eliminate post-processing substitute commands in
                            "			    favor of doing the work up front. Remove unnecessary
                            "			    special treatment of 'LineNr' highlight group. Minor
                            "			    speed improvements. Fix modeline mangling in
                            "			    generated output so it works for text in the first
                            "			    column. Fix missing line number and fold column in
                            "			    diff filler lines. Fix that some fonts have a 1px
                            "			    gap (using a dirty hack, improvements welcome). Add
                            "			    "colorscheme" meta tag. Does NOT include support for
                            "			    the new default foldtext added in v11, as the patch
                            "			    adding it has not yet been included in Vim.
                            "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
                            "			    Brabandt in
                            "			    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
                            "			    This patch has not yet been included in Vim, thus
                            "			    these changes are removed in the next version.
                            "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside
                            "			    multiple nested folds with dynamic folding on.
                            "			    Also fix problem with foldtext in this situation.
                            "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css
                            "			    and without html_no_pre, default value same as
                            "			    'wrap' option, (Andy Spencer). Don't use
                            "			    'fileencoding' for converted document encoding if
                            "			    'buftype' indicates a special buffer which isn't
                            "			    written.
                            "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab
                            "			    characters in generated output (Andy Spencer).
                            "			    Escape text that looks like a modeline so Vim
                            "			    doesn't use anything in the converted HTML as a
                            "			    modeline. Bugfixes: Fix folding when a fold starts
                            "			    before the conversion range. Remove fold column when
                            "			    there are no folds.
                            "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:
                            "		  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
                            "		  7.3_v7b2: Remove automatic detection of encodings that are not
                            "			    supported by all major browsers according to
                            "			    http://wiki.whatwg.org/wiki/Web_Encodings and
                            "			    convert to UTF-8 for all Unicode encodings. Make
                            "			    HTML encoding to Vim encoding detection be
                            "			    case-insensitive for built-in pairs.
                            "		  7.3_v7b1: Remove use of setwinvar() function which cannot be
                            "			    called in restricted mode (Andy Spencer). Use
                            "			    'fencoding' instead of 'encoding' to determine by
                            "			    charset, and make sure the 'fenc' of the generated
                            "			    file matches its indicated charset. Add charsets for
                            "			    all of Vim's natively supported encodings.
                            "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other
                            "			    user settings interfering with diff mode generation,
                            "			    trailing whitespace (e.g. line number column) when
                            "			    using html_no_pre, and bugs when using
                            "			    html_hover_unfold.
                            "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
                            "			    folds in diff mode when first line was folded.
                            "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode
                            "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css
                            "			    default to true when not set to anything. Use strict
                            "			    doctypes where possible. Rename use_xhtml option to
                            "			    html_use_xhtml for consistency. Use .xhtml extension
                            "			    when using this option. Add meta tag for settings.
                            "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the
                            "			    diff colors and the normal syntax colors
                            "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output
                            "}}}
                            "}}}
                            
                            " TODO: {{{
                            "   * Check the issue tracker:
                            "     https://bitbucket.org/fritzophrenic/vim-tohtml/issues?status=new&status=open
                            "   * Options for generating the CSS in external style sheets. New :TOcss
                            "     command to convert the current color scheme into a (mostly) generic CSS
                            "     stylesheet which can be re-used. Alternate stylesheet support? Good start
                            "     by Erik Falor
                            "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
                            "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
                            "     term) to use for the styling. Suggestion by "nacitar".
                            "   * Add way to override or specify which RGB colors map to the color numbers
                            "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
                            "   * Disable filetype detection until after all processing is done.
                            "   * Add option for not generating the hyperlink on stuff that looks like a
                            "     URL? Or just color the link to fit with the colorscheme (and only special
                            "     when hovering)?
                            "   * Bug: Opera does not allow printing more than one page if uncopyable
                            "     regions is turned on. Possible solution: Add normal text line numbers with
                            "     display:none, set to display:inline for print style sheets, and hide
                            "     <input> elements for print, to allow Opera printing multiple pages (and
                            "     other uncopyable areas?). May need to make the new text invisible to IE
                            "     with conditional comments to prevent copying it, IE for some reason likes
                            "     to copy hidden text. Other browsers too?
                            "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
                            "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
                            "     on Windows). Perhaps it is font related?
                            "   * Bug: still some gaps in the fold column when html_prevent_copy contains
                            "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
                            "     on diff lines though.
                            "   * Undercurl support via CSS3, with fallback to dotted or something:
                            "	https://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
                            "   * Redo updates for modified default foldtext (v11) when/if the patch is
                            "     accepted to modify it.
                            "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
                            "		+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
                            "		+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
                            "     does not show the whole diff filler as it is supposed to?
                            "   * Bug: when 'isprint' is wrong for the current encoding, will generate
                            "     invalid content. Can/should anything be done about this? Maybe a separate
                            "     plugin to correct 'isprint' based on encoding?
                            "   * Check to see if the windows-125\d encodings actually work in Unix without
                            "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
                            "   * Font auto-detection similar to
                            "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
                            "     platforms.
                            "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
                            "	- listchars support
                            "	- full-line background highlight
                            "	- other?
                            "   * Make it so deleted lines in a diff don't create side-scrolling (get it
                            "     free with full-line background highlight above).
                            "   * Restore open/closed folds and cursor position after processing each file
                            "     with option not to restore for speed increase.
                            "   * Add extra meta info (generation time, etc.)?
                            "   * Tidy up so we can use strict doctype in even more situations
                            "   * Implementation detail: add threshold for writing the lines to the html
                            "     buffer before we're done (5000 or so lines should do it)
                            "   * TODO comments for code cleanup scattered throughout
                            "}}}
                            
                            " Define the :TOhtml command when:
                            " - 'compatible' is not set
                            " - this plugin or user override was not already loaded
                            " - user commands are available. {{{
    1              0.000008 if !&cp && !exists(":TOhtml") && has("user_commands")
    1              0.000006   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
    1              0.000001 endif "}}}
                            
                            " Make sure any patches will probably use consistent indent
                            "   vim: ts=8 sw=2 sts=2 noet fdm=marker

SCRIPT  /usr/share/nvim/runtime/plugin/tutor.vim
Sourced 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000005 if exists('g:loaded_tutor_mode_plugin') || &compatible
                                finish
    1              0.000001 endif
    1              0.000002 let g:loaded_tutor_mode_plugin = 1
                            
    1              0.000005 command! -nargs=? -complete=custom,tutor#TutorCmdComplete Tutor call tutor#TutorCmd(<q-args>)

SCRIPT  /usr/share/nvim/runtime/plugin/zipPlugin.vim
Sourced 1 time
Total time:   0.000191
 Self time:   0.000191

count  total (s)   self (s)
                            " zipPlugin.vim: Handles browsing zipfiles
                            "            PLUGIN PORTION
                            " Date:			Jan 07, 2020
                            " Maintainer:	Charles E Campbell <NcampObell@SdrPchip.AorgM-NOSPAM>
                            " License:		Vim License  (see vim's :help license)
                            " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               zipPlugin.vim is provided *as is* and comes with no warranty
                            "               of any kind, either expressed or implied. By using this
                            "               plugin, you agree that in no event will the copyright
                            "               holder be liable for any damages resulting from the use
                            "               of this software.
                            "
                            " (James 4:8 WEB) Draw near to God, and he will draw near to you.
                            " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
                            " ---------------------------------------------------------------------
                            " Load Once: {{{1
    1              0.000006 if &cp || exists("g:loaded_zipPlugin")
                             finish
    1              0.000001 endif
    1              0.000002 let g:loaded_zipPlugin = "v32"
    1              0.000004 let s:keepcpo          = &cpo
    1              0.000005 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            " Options: {{{1
    1              0.000003 if !exists("g:zipPlugin_ext")
    1              0.000007  let g:zipPlugin_ext='*.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
    1              0.000001 endif
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000001 augroup zip
    1              0.000004  au!
    1              0.000004  au BufReadCmd   zipfile:*	call zip#Read(expand("<amatch>"), 1)
    1              0.000004  au FileReadCmd  zipfile:*	call zip#Read(expand("<amatch>"), 0)
    1              0.000004  au BufWriteCmd  zipfile:*	call zip#Write(expand("<amatch>"))
    1              0.000004  au FileWriteCmd zipfile:*	call zip#Write(expand("<amatch>"))
                            
    1              0.000002  if has("unix")
    1              0.000004   au BufReadCmd   zipfile:*/*	call zip#Read(expand("<amatch>"), 1)
    1              0.000004   au FileReadCmd  zipfile:*/*	call zip#Read(expand("<amatch>"), 0)
    1              0.000003   au BufWriteCmd  zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000003   au FileWriteCmd zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000001  endif
                            
    1              0.000097  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
    1              0.000001 augroup END
                            
                            " ---------------------------------------------------------------------
                            "  Restoration And Modelines: {{{1
                            "  vim: fdm=marker
    1              0.000008 let &cpo= s:keepcpo
    1              0.000002 unlet s:keepcpo

SCRIPT  /usr/share/vim/vimfiles/plugin/fzf.vim
Sourced 1 time
Total time:   0.000797
 Self time:   0.000797

count  total (s)   self (s)
                            " Copyright (c) 2013-2023 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    1              0.000003 if exists('g:loaded_fzf')
                              finish
    1              0.000001 endif
    1              0.000002 let g:loaded_fzf = 1
                            
    1              0.000006 let s:is_win = has('win32') || has('win64')
    1              0.000002 if s:is_win && &shellslash
                              set noshellslash
                              let s:base_dir = expand('<sfile>:h:h')
                              set shellslash
    1              0.000001 else
    1              0.000005   let s:base_dir = expand('<sfile>:h:h')
    1              0.000001 endif
    1              0.000001 if s:is_win
                              let s:term_marker = '&::FZF'
                            
                              function! s:fzf_call(fn, ...)
                                let shellslash = &shellslash
                                try
                                  set noshellslash
                                  return call(a:fn, a:000)
                                finally
                                  let &shellslash = shellslash
                                endtry
                              endfunction
                            
                              " Use utf-8 for fzf.vim commands
                              " Return array of shell commands for cmd.exe
                              function! s:enc_to_cp(str)
                                if !has('iconv')
                                  return a:str
                                endif
                                if !exists('s:codepage')
                                  let s:codepage = libcallnr('kernel32.dll', 'GetACP', 0)
                                endif
                                return iconv(a:str, &encoding, 'cp'.s:codepage)
                              endfunction
                              function! s:wrap_cmds(cmds)
                                return map([
                                  \ '@echo off',
                                  \ 'setlocal enabledelayedexpansion']
                                \ + (has('gui_running') ? ['set TERM= > nul'] : [])
                                \ + (type(a:cmds) == type([]) ? a:cmds : [a:cmds])
                                \ + ['endlocal'],
                                \ '<SID>enc_to_cp(v:val."\r")')
                              endfunction
    1              0.000001 else
    1              0.000002   let s:term_marker = ";#FZF"
                            
    1              0.000002   function! s:fzf_call(fn, ...)
                                return call(a:fn, a:000)
                              endfunction
                            
    1              0.000001   function! s:wrap_cmds(cmds)
                                return a:cmds
                              endfunction
                            
    1              0.000002   function! s:enc_to_cp(str)
                                return a:str
                              endfunction
    1              0.000001 endif
                            
    1              0.000002 function! s:shellesc_cmd(arg)
                              let escaped = substitute(a:arg, '[&|<>()@^]', '^&', 'g')
                              let escaped = substitute(escaped, '%', '%%', 'g')
                              let escaped = substitute(escaped, '"', '\\^&', 'g')
                              let escaped = substitute(escaped, '\(\\\+\)\(\\^\)', '\1\1\2', 'g')
                              return '^"'.substitute(escaped, '\(\\\+\)$', '\1\1', '').'^"'
                            endfunction
                            
    1              0.000002 function! fzf#shellescape(arg, ...)
                              let shell = get(a:000, 0, s:is_win ? 'cmd.exe' : 'sh')
                              if shell =~# 'cmd.exe$'
                                return s:shellesc_cmd(a:arg)
                              endif
                              try
                                let [shell, &shell] = [&shell, shell]
                                return s:fzf_call('shellescape', a:arg)
                              finally
                                let [shell, &shell] = [&shell, shell]
                              endtry
                            endfunction
                            
    1              0.000001 function! s:fzf_getcwd()
                              return s:fzf_call('getcwd')
                            endfunction
                            
    1              0.000002 function! s:fzf_fnamemodify(fname, mods)
                              return s:fzf_call('fnamemodify', a:fname, a:mods)
                            endfunction
                            
    1              0.000001 function! s:fzf_expand(fmt)
                              return s:fzf_call('expand', a:fmt, 1)
                            endfunction
                            
    1              0.000001 function! s:fzf_tempname()
                              return s:fzf_call('tempname')
                            endfunction
                            
    1              0.000005 let s:layout_keys = ['window', 'tmux', 'up', 'down', 'left', 'right']
    1              0.000003 let s:fzf_go = s:base_dir.'/bin/fzf'
    1              0.000003 let s:fzf_tmux = s:base_dir.'/bin/fzf-tmux'
                            
    1              0.000005 let s:cpo_save = &cpo
    1              0.000005 set cpo&vim
                            
    1              0.000002 function! s:popup_support()
                              return has('nvim') ? has('nvim-0.4') : has('popupwin') && has('patch-8.2.191')
                            endfunction
                            
    1              0.000001 function! s:default_layout()
                              return s:popup_support()
                                    \ ? { 'window' : { 'width': 0.9, 'height': 0.6 } }
                                    \ : { 'down': '~40%' }
                            endfunction
                            
    1              0.000001 function! fzf#install()
                              if s:is_win && !has('win32unix')
                                let script = s:base_dir.'/install.ps1'
                                if !filereadable(script)
                                  throw script.' not found'
                                endif
                                let script = 'powershell -ExecutionPolicy Bypass -file ' . shellescape(script)
                              else
                                let script = s:base_dir.'/install'
                                if !executable(script)
                                  throw script.' not found'
                                endif
                                let script .= ' --bin'
                              endif
                            
                              call s:warn('Running fzf installer ...')
                              call system(script)
                              if v:shell_error
                                throw 'Failed to download fzf: '.script
                              endif
                            endfunction
                            
    1              0.000003 let s:versions = {}
    1              0.000002 function s:get_version(bin)
                              if has_key(s:versions, a:bin)
                                return s:versions[a:bin]
                              end
                              let command = (&shell =~ 'powershell' ? '&' : '') . s:fzf_call('shellescape', a:bin) . ' --version --no-height'
                              let output = systemlist(command)
                              if v:shell_error || empty(output)
                                return ''
                              endif
                              let ver = matchstr(output[-1], '[0-9.]\+')
                              let s:versions[a:bin] = ver
                              return ver
                            endfunction
                            
    1              0.000002 function! s:compare_versions(a, b)
                              let a = split(a:a, '\.')
                              let b = split(a:b, '\.')
                              for idx in range(0, max([len(a), len(b)]) - 1)
                                let v1 = str2nr(get(a, idx, 0))
                                let v2 = str2nr(get(b, idx, 0))
                                if     v1 < v2 | return -1
                                elseif v1 > v2 | return 1
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000002 function! s:compare_binary_versions(a, b)
                              return s:compare_versions(s:get_version(a:a), s:get_version(a:b))
                            endfunction
                            
    1              0.000002 let s:checked = {}
    1              0.000001 function! fzf#exec(...)
                              if !exists('s:exec')
                                let binaries = []
                                if executable('fzf')
                                  call add(binaries, 'fzf')
                                endif
                                if executable(s:fzf_go)
                                  call add(binaries, s:fzf_go)
                                endif
                            
                                if empty(binaries)
                                  if input('fzf executable not found. Download binary? (y/n) ') =~? '^y'
                                    redraw
                                    call fzf#install()
                                    return fzf#exec()
                                  else
                                    redraw
                                    throw 'fzf executable not found'
                                  endif
                                elseif len(binaries) > 1
                                  call sort(binaries, 's:compare_binary_versions')
                                endif
                            
                                let s:exec = binaries[-1]
                              endif
                            
                              if a:0 && !has_key(s:checked, a:1)
                                let fzf_version = s:get_version(s:exec)
                                if empty(fzf_version)
                                  let message = printf('Failed to run "%s --version"', s:exec)
                                  unlet s:exec
                                  throw message
                                end
                            
                                if s:compare_versions(fzf_version, a:1) >= 0
                                  let s:checked[a:1] = 1
                                  return s:exec
                                elseif a:0 < 2 && input(printf('You need fzf %s or above. Found: %s. Download binary? (y/n) ', a:1, fzf_version)) =~? '^y'
                                  let s:versions = {}
                                  unlet s:exec
                                  redraw
                                  call fzf#install()
                                  return fzf#exec(a:1, 1)
                                else
                                  throw printf('You need to upgrade fzf (required: %s or above)', a:1)
                                endif
                              endif
                            
                              return s:exec
                            endfunction
                            
    1              0.000001 function! s:tmux_enabled()
                              if has('gui_running') || !exists('$TMUX')
                                return 0
                              endif
                            
                              if exists('s:tmux')
                                return s:tmux
                              endif
                            
                              let s:tmux = 0
                              if !executable(s:fzf_tmux)
                                if executable('fzf-tmux')
                                  let s:fzf_tmux = 'fzf-tmux'
                                else
                                  return 0
                                endif
                              endif
                            
                              let output = system('tmux -V')
                              let s:tmux = !v:shell_error && output >= 'tmux 1.7'
                              return s:tmux
                            endfunction
                            
    1              0.000002 function! s:escape(path)
                              let path = fnameescape(a:path)
                              return s:is_win ? escape(path, '$') : path
                            endfunction
                            
    1              0.000001 function! s:error(msg)
                              echohl ErrorMsg
                              echom a:msg
                              echohl None
                            endfunction
                            
    1              0.000001 function! s:warn(msg)
                              echohl WarningMsg
                              echom a:msg
                              echohl None
                            endfunction
                            
    1              0.000002 function! s:has_any(dict, keys)
                              for key in a:keys
                                if has_key(a:dict, key)
                                  return 1
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000001 function! s:open(cmd, target)
                              if stridx('edit', a:cmd) == 0 && s:fzf_fnamemodify(a:target, ':p') ==# s:fzf_expand('%:p')
                                return
                              endif
                              execute a:cmd s:escape(a:target)
                            endfunction
                            
    1              0.000002 function! s:common_sink(action, lines) abort
                              if len(a:lines) < 2
                                return
                              endif
                              let key = remove(a:lines, 0)
                              let Cmd = get(a:action, key, 'e')
                              if type(Cmd) == type(function('call'))
                                return Cmd(a:lines)
                              endif
                              if len(a:lines) > 1
                                augroup fzf_swap
                                  autocmd SwapExists * let v:swapchoice='o'
                                        \| call s:warn('fzf: E325: swap file exists: '.s:fzf_expand('<afile>'))
                                augroup END
                              endif
                              try
                                let empty = empty(s:fzf_expand('%')) && line('$') == 1 && empty(getline(1)) && !&modified
                                " Preserve the current working directory in case it's changed during
                                " the execution (e.g. `set autochdir` or `autocmd BufEnter * lcd ...`)
                                let cwd = exists('w:fzf_pushd') ? w:fzf_pushd.dir : expand('%:p:h')
                                for item in a:lines
                                  if item[0] != '~' && item !~ (s:is_win ? '^[A-Z]:\' : '^/')
                                    let sep = s:is_win ? '\' : '/'
                                    let item = join([cwd, item], cwd[len(cwd)-1] == sep ? '' : sep)
                                  endif
                                  if empty
                                    execute 'e' s:escape(item)
                                    let empty = 0
                                  else
                                    call s:open(Cmd, item)
                                  endif
                                  if !has('patch-8.0.0177') && !has('nvim-0.2') && exists('#BufEnter')
                                        \ && isdirectory(item)
                                    doautocmd BufEnter
                                  endif
                                endfor
                              catch /^Vim:Interrupt$/
                              finally
                                silent! autocmd! fzf_swap
                              endtry
                            endfunction
                            
    1              0.000002 function! s:get_color(attr, ...)
                              " Force 24 bit colors: g:fzf_force_termguicolors (temporary workaround for https://github.com/junegunn/fzf.vim/issues/1152)
                              let gui = get(g:, 'fzf_force_termguicolors', 0) || (!s:is_win && !has('win32unix') && has('termguicolors') && &termguicolors)
                              let fam = gui ? 'gui' : 'cterm'
                              let pat = gui ? '^#[a-f0-9]\+' : '^[0-9]\+$'
                              for group in a:000
                                let code = synIDattr(synIDtrans(hlID(group)), a:attr, fam)
                                if code =~? pat
                                  return code
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000001 function! s:defaults()
                              let rules = copy(get(g:, 'fzf_colors', {}))
                              let colors = join(map(items(filter(map(rules, 'call("s:get_color", v:val)'), '!empty(v:val)')), 'join(v:val, ":")'), ',')
                              return empty(colors) ? '' : fzf#shellescape('--color='.colors)
                            endfunction
                            
    1              0.000002 function! s:validate_layout(layout)
                              for key in keys(a:layout)
                                if index(s:layout_keys, key) < 0
                                  throw printf('Invalid entry in g:fzf_layout: %s (allowed: %s)%s',
                                        \ key, join(s:layout_keys, ', '), key == 'options' ? '. Use $FZF_DEFAULT_OPTS.' : '')
                                endif
                              endfor
                              return a:layout
                            endfunction
                            
    1              0.000001 function! s:evaluate_opts(options)
                              return type(a:options) == type([]) ?
                                    \ join(map(copy(a:options), 'fzf#shellescape(v:val)')) : a:options
                            endfunction
                            
                            " [name string,] [opts dict,] [fullscreen boolean]
    1              0.000001 function! fzf#wrap(...)
                              let args = ['', {}, 0]
                              let expects = map(copy(args), 'type(v:val)')
                              let tidx = 0
                              for arg in copy(a:000)
                                let tidx = index(expects, type(arg) == 6 ? type(0) : type(arg), tidx)
                                if tidx < 0
                                  throw 'Invalid arguments (expected: [name string] [opts dict] [fullscreen boolean])'
                                endif
                                let args[tidx] = arg
                                let tidx += 1
                                unlet arg
                              endfor
                              let [name, opts, bang] = args
                            
                              if len(name)
                                let opts.name = name
                              end
                            
                              " Layout: g:fzf_layout (and deprecated g:fzf_height)
                              if bang
                                for key in s:layout_keys
                                  if has_key(opts, key)
                                    call remove(opts, key)
                                  endif
                                endfor
                              elseif !s:has_any(opts, s:layout_keys)
                                if !exists('g:fzf_layout') && exists('g:fzf_height')
                                  let opts.down = g:fzf_height
                                else
                                  let opts = extend(opts, s:validate_layout(get(g:, 'fzf_layout', s:default_layout())))
                                endif
                              endif
                            
                              " Colors: g:fzf_colors
                              let opts.options = s:defaults() .' '. s:evaluate_opts(get(opts, 'options', ''))
                            
                              " History: g:fzf_history_dir
                              if len(name) && len(get(g:, 'fzf_history_dir', ''))
                                let dir = s:fzf_expand(g:fzf_history_dir)
                                if !isdirectory(dir)
                                  call mkdir(dir, 'p')
                                endif
                                let history = fzf#shellescape(dir.'/'.name)
                                let opts.options = join(['--history', history, opts.options])
                              endif
                            
                              " Action: g:fzf_action
                              if !s:has_any(opts, ['sink', 'sinklist', 'sink*'])
                                let opts._action = get(g:, 'fzf_action', s:default_action)
                                let opts.options .= ' --expect='.join(keys(opts._action), ',')
                                function! opts.sinklist(lines) abort
                                  return s:common_sink(self._action, a:lines)
                                endfunction
                                let opts['sink*'] = opts.sinklist " For backward compatibility
                              endif
                            
                              return opts
                            endfunction
                            
    1              0.000001 function! s:use_sh()
                              let [shell, shellslash, shellcmdflag, shellxquote] = [&shell, &shellslash, &shellcmdflag, &shellxquote]
                              if s:is_win
                                set shell=cmd.exe
                                set noshellslash
                                let &shellcmdflag = has('nvim') ? '/s /c' : '/c'
                                let &shellxquote = has('nvim') ? '"' : '('
                              else
                                set shell=sh
                              endif
                              return [shell, shellslash, shellcmdflag, shellxquote]
                            endfunction
                            
    1              0.000001 function! s:writefile(...)
                              if call('writefile', a:000) == -1
                                throw 'Failed to write temporary file. Check if you can write to the path tempname() returns.'
                              endif
                            endfunction
                            
    1              0.000001 function! fzf#run(...) abort
                            try
                              let [shell, shellslash, shellcmdflag, shellxquote] = s:use_sh()
                            
                              let dict   = exists('a:1') ? copy(a:1) : {}
                              let temps  = { 'result': s:fzf_tempname() }
                              let optstr = s:evaluate_opts(get(dict, 'options', ''))
                              try
                                let fzf_exec = shellescape(fzf#exec())
                              catch
                                throw v:exception
                              endtry
                            
                              if !s:present(dict, 'dir')
                                let dict.dir = s:fzf_getcwd()
                              endif
                              if has('win32unix') && s:present(dict, 'dir')
                                let dict.dir = fnamemodify(dict.dir, ':p')
                              endif
                            
                              if has_key(dict, 'source')
                                let source = remove(dict, 'source')
                                let type = type(source)
                                if type == 1
                                  let source_command = source
                                elseif type == 3
                                  let temps.input = s:fzf_tempname()
                                  call s:writefile(source, temps.input)
                                  let source_command = (s:is_win ? 'type ' : 'cat ').fzf#shellescape(temps.input)
                                else
                                  throw 'Invalid source type'
                                endif
                              else
                                let source_command = ''
                              endif
                            
                              let prefer_tmux = get(g:, 'fzf_prefer_tmux', 0) || has_key(dict, 'tmux')
                              let use_height = has_key(dict, 'down') && !has('gui_running') &&
                                    \ !(has('nvim') || s:is_win || has('win32unix') || s:present(dict, 'up', 'left', 'right', 'window')) &&
                                    \ executable('tput') && filereadable('/dev/tty')
                              let has_vim8_term = has('terminal') && has('patch-8.0.995')
                              let has_nvim_term = has('nvim-0.2.1') || has('nvim') && !s:is_win
                              let use_term = has_nvim_term ||
                                \ has_vim8_term && !has('win32unix') && (has('gui_running') || s:is_win || s:present(dict, 'down', 'up', 'left', 'right', 'window'))
                              let use_tmux = (has_key(dict, 'tmux') || (!use_height && !use_term || prefer_tmux) && !has('win32unix') && s:splittable(dict)) && s:tmux_enabled()
                              if prefer_tmux && use_tmux
                                let use_height = 0
                                let use_term = 0
                              endif
                              if use_term
                                let optstr .= ' --no-height'
                              elseif use_height
                                let height = s:calc_size(&lines, dict.down, dict)
                                let optstr .= ' --height='.height
                              endif
                              " Respect --border option given in 'options'
                              if stridx(optstr, '--border') < 0 && stridx(optstr, '--no-border') < 0
                                let optstr .= s:border_opt(get(dict, 'window', 0))
                              endif
                              let prev_default_command = $FZF_DEFAULT_COMMAND
                              if len(source_command)
                                let $FZF_DEFAULT_COMMAND = source_command
                              endif
                              let command = (use_tmux ? s:fzf_tmux(dict) : fzf_exec).' '.optstr.' > '.temps.result
                            
                              if use_term
                                return s:execute_term(dict, command, temps)
                              endif
                            
                              let lines = use_tmux ? s:execute_tmux(dict, command, temps)
                                             \ : s:execute(dict, command, use_height, temps)
                              call s:callback(dict, lines)
                              return lines
                            finally
                              if exists('source_command') && len(source_command)
                                if len(prev_default_command)
                                  let $FZF_DEFAULT_COMMAND = prev_default_command
                                else
                                  let $FZF_DEFAULT_COMMAND = ''
                                  silent! execute 'unlet $FZF_DEFAULT_COMMAND'
                                endif
                              endif
                              let [&shell, &shellslash, &shellcmdflag, &shellxquote] = [shell, shellslash, shellcmdflag, shellxquote]
                            endtry
                            endfunction
                            
    1              0.000002 function! s:present(dict, ...)
                              for key in a:000
                                if !empty(get(a:dict, key, ''))
                                  return 1
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000002 function! s:fzf_tmux(dict)
                              let size = get(a:dict, 'tmux', '')
                              if empty(size)
                                for o in ['up', 'down', 'left', 'right']
                                  if s:present(a:dict, o)
                                    let spec = a:dict[o]
                                    if (o == 'up' || o == 'down') && spec[0] == '~'
                                      let size = '-'.o[0].s:calc_size(&lines, spec, a:dict)
                                    else
                                      " Legacy boolean option
                                      let size = '-'.o[0].(spec == 1 ? '' : substitute(spec, '^\~', '', ''))
                                    endif
                                    break
                                  endif
                                endfor
                              endif
                              return printf('LINES=%d COLUMNS=%d %s %s - --',
                                \ &lines, &columns, fzf#shellescape(s:fzf_tmux), size)
                            endfunction
                            
    1              0.000002 function! s:splittable(dict)
                              return s:present(a:dict, 'up', 'down') && &lines > 15 ||
                                    \ s:present(a:dict, 'left', 'right') && &columns > 40
                            endfunction
                            
    1              0.000001 function! s:pushd(dict)
                              if s:present(a:dict, 'dir')
                                let cwd = s:fzf_getcwd()
                                let w:fzf_pushd = {
                                \   'command': haslocaldir() ? 'lcd' : (exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd'),
                                \   'origin': cwd,
                                \   'bufname': bufname('')
                                \ }
                                execute 'lcd' s:escape(a:dict.dir)
                                let cwd = s:fzf_getcwd()
                                let w:fzf_pushd.dir = cwd
                                let a:dict.pushd = w:fzf_pushd
                                return cwd
                              endif
                              return ''
                            endfunction
                            
    1              0.000002 augroup fzf_popd
    1              0.000006   autocmd!
    1              0.000008   autocmd WinEnter * call s:dopopd()
    1              0.000001 augroup END
                            
    1              0.000001 function! s:dopopd()
                              if !exists('w:fzf_pushd')
                                return
                              endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
                              if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
                                execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
                              endif
                              unlet! w:fzf_pushd
                            endfunction
                            
    1              0.000001 function! s:xterm_launcher()
                              let fmt = 'xterm -T "[fzf]" -bg "%s" -fg "%s" -geometry %dx%d+%d+%d -e bash -ic %%s'
                              if has('gui_macvim')
                                let fmt .= '&& osascript -e "tell application \"MacVim\" to activate"'
                              endif
                              return printf(fmt,
                                \ escape(synIDattr(hlID("Normal"), "bg"), '#'), escape(synIDattr(hlID("Normal"), "fg"), '#'),
                                \ &columns, &lines/2, getwinposx(), getwinposy())
                            endfunction
    1              0.000002 unlet! s:launcher
    1              0.000005 if s:is_win || has('win32unix')
                              let s:launcher = '%s'
    1              0.000001 else
    1              0.000007   let s:launcher = function('s:xterm_launcher')
    1              0.000001 endif
                            
    1              0.000002 function! s:exit_handler(code, command, ...)
                              if a:code == 130
                                return 0
                              elseif has('nvim') && a:code == 129
                                " When deleting the terminal buffer while fzf is still running,
                                " Nvim sends SIGHUP.
                                return 0
                              elseif a:code > 1
                                call s:error('Error running ' . a:command)
                                if !empty(a:000)
                                  sleep
                                endif
                                return 0
                              endif
                              return 1
                            endfunction
                            
    1              0.000003 function! s:execute(dict, command, use_height, temps) abort
                              call s:pushd(a:dict)
                              if has('unix') && !a:use_height
                                silent! !clear 2> /dev/null
                              endif
                              let escaped = (a:use_height || s:is_win) ? a:command : escape(substitute(a:command, '\n', '\\n', 'g'), '%#!')
                              if has('gui_running')
                                let Launcher = get(a:dict, 'launcher', get(g:, 'Fzf_launcher', get(g:, 'fzf_launcher', s:launcher)))
                                let fmt = type(Launcher) == 2 ? call(Launcher, []) : Launcher
                                if has('unix')
                                  let escaped = "'".substitute(escaped, "'", "'\"'\"'", 'g')."'"
                                endif
                                let command = printf(fmt, escaped)
                              else
                                let command = escaped
                              endif
                              if s:is_win
                                let batchfile = s:fzf_tempname().'.bat'
                                call s:writefile(s:wrap_cmds(command), batchfile)
                                let command = batchfile
                                let a:temps.batchfile = batchfile
                                if has('nvim')
                                  let fzf = {}
                                  let fzf.dict = a:dict
                                  let fzf.temps = a:temps
                                  function! fzf.on_exit(job_id, exit_status, event) dict
                                    call s:pushd(self.dict)
                                    let lines = s:collect(self.temps)
                                    call s:callback(self.dict, lines)
                                  endfunction
                                  let cmd = 'start /wait cmd /c '.command
                                  call jobstart(cmd, fzf)
                                  return []
                                endif
                              elseif has('win32unix') && $TERM !=# 'cygwin'
                                let shellscript = s:fzf_tempname()
                                call s:writefile([command], shellscript)
                                let command = 'cmd.exe /C '.fzf#shellescape('set "TERM=" & start /WAIT sh -c '.shellscript)
                                let a:temps.shellscript = shellscript
                              endif
                              if a:use_height
                                call system(printf('tput cup %d > /dev/tty; tput cnorm > /dev/tty; %s < /dev/tty 2> /dev/tty', &lines, command))
                              else
                                execute 'silent !'.command
                              endif
                              let exit_status = v:shell_error
                              redraw!
                              let lines = s:collect(a:temps)
                              return s:exit_handler(exit_status, command) ? lines : []
                            endfunction
                            
    1              0.000002 function! s:execute_tmux(dict, command, temps) abort
                              let command = a:command
                              let cwd = s:pushd(a:dict)
                              if len(cwd)
                                " -c '#{pane_current_path}' is only available on tmux 1.9 or above
                                let command = join(['cd', fzf#shellescape(cwd), '&&', command])
                              endif
                            
                              call system(command)
                              let exit_status = v:shell_error
                              redraw!
                              let lines = s:collect(a:temps)
                              return s:exit_handler(exit_status, command) ? lines : []
                            endfunction
                            
    1              0.000002 function! s:calc_size(max, val, dict)
                              let val = substitute(a:val, '^\~', '', '')
                              if val =~ '%$'
                                let size = a:max * str2nr(val[:-2]) / 100
                              else
                                let size = min([a:max, str2nr(val)])
                              endif
                            
                              let srcsz = -1
                              if type(get(a:dict, 'source', 0)) == type([])
                                let srcsz = len(a:dict.source)
                              endif
                            
                              let opts = $FZF_DEFAULT_OPTS.' '.s:evaluate_opts(get(a:dict, 'options', ''))
                              if opts =~ 'preview'
                                return size
                              endif
                              let margin = match(opts, '--inline-info\|--info[^-]\{-}inline') > match(opts, '--no-inline-info\|--info[^-]\{-}\(default\|hidden\)') ? 1 : 2
                              let margin += stridx(opts, '--border') > stridx(opts, '--no-border') ? 2 : 0
                              if stridx(opts, '--header') > stridx(opts, '--no-header')
                                let margin += len(split(opts, "\n"))
                              endif
                              return srcsz >= 0 ? min([srcsz + margin, size]) : size
                            endfunction
                            
    1              0.000001 function! s:getpos()
                              return {'tab': tabpagenr(), 'win': winnr(), 'winid': win_getid(), 'cnt': winnr('$'), 'tcnt': tabpagenr('$')}
                            endfunction
                            
    1              0.000001 function! s:border_opt(window)
                              if type(a:window) != type({})
                                return ''
                              endif
                            
                              " Border style
                              let style = tolower(get(a:window, 'border', ''))
                              if !has_key(a:window, 'border') && has_key(a:window, 'rounded')
                                let style = a:window.rounded ? 'rounded' : 'sharp'
                              endif
                              if style == 'none' || style == 'no'
                                return ''
                              endif
                            
                              " For --border styles, we need fzf 0.24.0 or above
                              call fzf#exec('0.24.0')
                              let opt = ' --border ' . style
                              if has_key(a:window, 'highlight')
                                let color = s:get_color('fg', a:window.highlight)
                                if len(color)
                                  let opt .= ' --color=border:' . color
                                endif
                              endif
                              return opt
                            endfunction
                            
    1              0.000001 function! s:split(dict)
                              let directions = {
                              \ 'up':    ['topleft', 'resize', &lines],
                              \ 'down':  ['botright', 'resize', &lines],
                              \ 'left':  ['vertical topleft', 'vertical resize', &columns],
                              \ 'right': ['vertical botright', 'vertical resize', &columns] }
                              let ppos = s:getpos()
                              let is_popup = 0
                              try
                                if s:present(a:dict, 'window')
                                  if type(a:dict.window) == type({})
                                    if !s:popup_support()
                                      throw 'Nvim 0.4+ or Vim 8.2.191+ with popupwin feature is required for pop-up window'
                                    end
                                    call s:popup(a:dict.window)
                                    let is_popup = 1
                                  else
                                    execute 'keepalt' a:dict.window
                                  endif
                                elseif !s:splittable(a:dict)
                                  execute (tabpagenr()-1).'tabnew'
                                else
                                  for [dir, triple] in items(directions)
                                    let val = get(a:dict, dir, '')
                                    if !empty(val)
                                      let [cmd, resz, max] = triple
                                      if (dir == 'up' || dir == 'down') && val[0] == '~'
                                        let sz = s:calc_size(max, val, a:dict)
                                      else
                                        let sz = s:calc_size(max, val, {})
                                      endif
                                      execute cmd sz.'new'
                                      execute resz sz
                                      return [ppos, {}, is_popup]
                                    endif
                                  endfor
                                endif
                                return [ppos, is_popup ? {} : { '&l:wfw': &l:wfw, '&l:wfh': &l:wfh }, is_popup]
                              finally
                                if !is_popup
                                  setlocal winfixwidth winfixheight
                                endif
                              endtry
                            endfunction
                            
    1              0.000008 nnoremap <silent> <Plug>(fzf-insert) i
    1              0.000004 nnoremap <silent> <Plug>(fzf-normal) <Nop>
    1              0.000003 if exists(':tnoremap')
    1              0.000005   tnoremap <silent> <Plug>(fzf-insert) <C-\><C-n>i
    1              0.000004   tnoremap <silent> <Plug>(fzf-normal) <C-\><C-n>
    1              0.000001 endif
                            
    1              0.000004 let s:warned = 0
    1              0.000002 function! s:handle_ambidouble(dict)
                              if &ambiwidth == 'double'
                                let a:dict.env = { 'RUNEWIDTH_EASTASIAN': '1' }
                              elseif !s:warned && $RUNEWIDTH_EASTASIAN == '1' && &ambiwidth !=# 'double'
                                call s:warn("$RUNEWIDTH_EASTASIAN is '1' but &ambiwidth is not 'double'")
                                2sleep
                                let s:warned = 1
                              endif
                            endfunction
                            
    1              0.000002 function! s:execute_term(dict, command, temps) abort
                              let winrest = winrestcmd()
                              let pbuf = bufnr('')
                              let [ppos, winopts, is_popup] = s:split(a:dict)
                              call s:use_sh()
                              let b:fzf = a:dict
                              let fzf = { 'buf': bufnr(''), 'pbuf': pbuf, 'ppos': ppos, 'dict': a:dict, 'temps': a:temps,
                                        \ 'winopts': winopts, 'winrest': winrest, 'lines': &lines,
                                        \ 'columns': &columns, 'command': a:command }
                              function! fzf.switch_back(inplace)
                                if a:inplace && bufnr('') == self.buf
                                  if bufexists(self.pbuf)
                                    execute 'keepalt keepjumps b' self.pbuf
                                  endif
                                  " No other listed buffer
                                  if bufnr('') == self.buf
                                    enew
                                  endif
                                endif
                              endfunction
                              function! fzf.on_exit(id, code, ...)
                                if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
                                else
                                  if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
                                    close
                                  endif
                                  silent! execute 'tabnext' self.ppos.tab
                                  silent! execute self.ppos.win.'wincmd w'
                                endif
                            
                                if bufexists(self.buf)
                                  execute 'bd!' self.buf
                                endif
                            
                                if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
                                  execute self.winrest
                                endif
                            
                                let lines = s:collect(self.temps)
                                if !s:exit_handler(a:code, self.command, 1)
                                  return
                                endif
                            
                                call s:pushd(self.dict)
                                call s:callback(self.dict, lines)
                                call self.switch_back(s:getpos() == self.ppos)
                            
                                if &buftype == 'terminal'
                                  call feedkeys(&filetype == 'fzf' ? "\<Plug>(fzf-insert)" : "\<Plug>(fzf-normal)")
                                endif
                              endfunction
                            
                              try
                                call s:pushd(a:dict)
                                if s:is_win
                                  let fzf.temps.batchfile = s:fzf_tempname().'.bat'
                                  call s:writefile(s:wrap_cmds(a:command), fzf.temps.batchfile)
                                  let command = fzf.temps.batchfile
                                else
                                  let command = a:command
                                endif
                                let command .= s:term_marker
                                if has('nvim')
                                  call s:handle_ambidouble(fzf)
                                  call termopen(command, fzf)
                                else
                                  let term_opts = {'exit_cb': function(fzf.on_exit)}
                                  if v:version >= 802
                                    let term_opts.term_kill = 'term'
                                  endif
                                  if is_popup
                                    let term_opts.hidden = 1
                                  else
                                    let term_opts.curwin = 1
                                  endif
                                  call s:handle_ambidouble(term_opts)
                                  let fzf.buf = term_start([&shell, &shellcmdflag, command], term_opts)
                                  if is_popup && exists('#TerminalWinOpen')
                                    doautocmd <nomodeline> TerminalWinOpen
                                  endif
                                  if !has('patch-8.0.1261') && !s:is_win
                                    call term_wait(fzf.buf, 20)
                                  endif
                                endif
                                tnoremap <buffer> <c-z> <nop>
                                if exists('&termwinkey') && (empty(&termwinkey) || &termwinkey =~? '<c-w>')
                                  tnoremap <buffer> <c-w> <c-w>.
                                endif
                              finally
                                call s:dopopd()
                              endtry
                              setlocal nospell bufhidden=wipe nobuflisted nonumber
                              setf fzf
                              startinsert
                              return []
                            endfunction
                            
    1              0.000001 function! s:collect(temps) abort
                              try
                                return filereadable(a:temps.result) ? readfile(a:temps.result) : []
                              finally
                                for tf in values(a:temps)
                                  silent! call delete(tf)
                                endfor
                              endtry
                            endfunction
                            
    1              0.000002 function! s:callback(dict, lines) abort
                              let popd = has_key(a:dict, 'pushd')
                              if popd
                                let w:fzf_pushd = a:dict.pushd
                              endif
                            
                              try
                                if has_key(a:dict, 'sink')
                                  for line in a:lines
                                    if type(a:dict.sink) == 2
                                      call a:dict.sink(line)
                                    else
                                      execute a:dict.sink s:escape(line)
                                    endif
                                  endfor
                                endif
                                if has_key(a:dict, 'sink*')
                                  call a:dict['sink*'](a:lines)
                                elseif has_key(a:dict, 'sinklist')
                                  call a:dict['sinklist'](a:lines)
                                endif
                              catch
                                if stridx(v:exception, ':E325:') < 0
                                  echoerr v:exception
                                endif
                              endtry
                            
                              " We may have opened a new window or tab
                              if popd
                                let w:fzf_pushd = a:dict.pushd
                                call s:dopopd()
                              endif
                            endfunction
                            
    1              0.000004 if has('nvim')
    1              0.000002   function s:create_popup(opts) abort
                                let buf = nvim_create_buf(v:false, v:true)
                                let opts = extend({'relative': 'editor', 'style': 'minimal'}, a:opts)
                                let win = nvim_open_win(buf, v:true, opts)
                                silent! call setwinvar(win, '&winhighlight', 'Pmenu:,Normal:Normal')
                                call setwinvar(win, '&colorcolumn', '')
                                return buf
                              endfunction
                            else
                              function! s:create_popup(opts) abort
                                let s:popup_create = {buf -> popup_create(buf, #{
                                  \ line: a:opts.row,
                                  \ col: a:opts.col,
                                  \ minwidth: a:opts.width,
                                  \ maxwidth: a:opts.width,
                                  \ minheight: a:opts.height,
                                  \ maxheight: a:opts.height,
                                  \ zindex: 1000,
                                \ })}
                                autocmd TerminalOpen * ++once call s:popup_create(str2nr(expand('<abuf>')))
                              endfunction
    1              0.000001 endif
                            
    1              0.000001 function! s:popup(opts) abort
                              let xoffset = get(a:opts, 'xoffset', 0.5)
                              let yoffset = get(a:opts, 'yoffset', 0.5)
                              let relative = get(a:opts, 'relative', 0)
                            
                              " Use current window size for positioning relatively positioned popups
                              let columns = relative ? winwidth(0) : &columns
                              let lines = relative ? winheight(0) : (&lines - has('nvim'))
                            
                              " Size and position
                              let width = min([max([8, a:opts.width > 1 ? a:opts.width : float2nr(columns * a:opts.width)]), columns])
                              let height = min([max([4, a:opts.height > 1 ? a:opts.height : float2nr(lines * a:opts.height)]), lines])
                              let row = float2nr(yoffset * (lines - height)) + (relative ? win_screenpos(0)[0] - 1 : 0)
                              let col = float2nr(xoffset * (columns - width)) + (relative ? win_screenpos(0)[1] - 1 : 0)
                            
                              " Managing the differences
                              let row = min([max([0, row]), &lines - has('nvim') - height])
                              let col = min([max([0, col]), &columns - width])
                              let row += !has('nvim')
                              let col += !has('nvim')
                            
                              call s:create_popup({
                                \ 'row': row, 'col': col, 'width': width, 'height': height
                              \ })
                            endfunction
                            
    1              0.000007 let s:default_action = {
                              \ 'ctrl-t': 'tab split',
                              \ 'ctrl-x': 'split',
                              \ 'ctrl-v': 'vsplit' }
                            
    1              0.000001 function! s:shortpath()
                              let short = fnamemodify(getcwd(), ':~:.')
                              if !has('win32unix')
                                let short = pathshorten(short)
                              endif
                              let slash = (s:is_win && !&shellslash) ? '\' : '/'
                              return empty(short) ? '~'.slash : short . (short =~ escape(slash, '\').'$' ? '' : slash)
                            endfunction
                            
    1              0.000001 function! s:cmd(bang, ...) abort
                              let args = copy(a:000)
                              let opts = { 'options': ['--multi'] }
                              if len(args) && isdirectory(expand(args[-1]))
                                let opts.dir = substitute(substitute(remove(args, -1), '\\\(["'']\)', '\1', 'g'), '[/\\]*$', '/', '')
                                if s:is_win && !&shellslash
                                  let opts.dir = substitute(opts.dir, '/', '\\', 'g')
                                endif
                                let prompt = opts.dir
                              else
                                let prompt = s:shortpath()
                              endif
                              let prompt = strwidth(prompt) < &columns - 20 ? prompt : '> '
                              call extend(opts.options, ['--prompt', prompt])
                              call extend(opts.options, args)
                              call fzf#run(fzf#wrap('FZF', opts, a:bang))
                            endfunction
                            
    1              0.000006 command! -nargs=* -complete=dir -bang FZF call s:cmd(<bang>0, <f-args>)
                            
    1              0.000009 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save

SCRIPT  /usr/share/vim/vimfiles/plugin/redact_pass.vim
Sourced 1 time
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
                            "
                            " redact_pass.vim: Switch off the 'viminfo', 'backup', 'writebackup',
                            " 'swapfile', and 'undofile' globally when editing a password in pass(1).
                            "
                            " This is to prevent anyone being able to extract passwords from your Vim
                            " cache files in the event of a compromise.
                            "
                            " Author: Tom Ryder <tom@sanctum.geek.nz>
                            " License: Same as Vim itself
                            "
    1              0.000004 if exists('g:loaded_redact_pass') || &compatible
                              finish
    1              0.000001 endif
    1              0.000004 if !has('autocmd') || v:version < 600
                              finish
    1              0.000001 endif
    1              0.000002 let g:loaded_redact_pass = 1
                            
                            " Check whether we should set redacting options or not
    1              0.000002 function! s:CheckArgsRedact()
                            
                              " Ensure there's one argument and it's the matched file
                              if argc() != 1 || fnamemodify(argv(0), ':p') !=# expand('<afile>:p')
                                return
                              endif
                            
                              " Disable all the leaky options globally
                              set nobackup
                              set nowritebackup
                              set noswapfile
                              set viminfo=
                              if has('persistent_undo')
                                set noundofile
                              endif
                            
                              " Tell the user what we're doing so they know this worked, via a message and
                              " a global variable they can check
                              redraw
                              echomsg 'Editing password file--disabled leaky options!'
                              let g:redact_pass_redacted = 1
                            
                            endfunction
                            
                            " Auto function loads only when Vim starts up
    1              0.000002 augroup redact_pass
    1              0.000005   autocmd!
    1              0.000019   autocmd VimEnter
                                    \ /dev/shm/pass.?*/?*.txt
                                    \,$TMPDIR/pass.?*/?*.txt
                                    \,/tmp/pass.?*/?*.txt
                                    \ call s:CheckArgsRedact()
                              " Work around macOS' dynamic symlink structure for temporary directories
    1              0.000004   if has('mac')
                                autocmd VimEnter
                                      \ /private/var/?*/pass.?*/?*.txt
                                      \ call s:CheckArgsRedact()
    1              0.000001   endif
    1              0.000001 augroup END

SCRIPT  /home/benk/.config/nvim/plugin/packer_compiled.lua
Sourced 1 time
Total time:   0.011249
 Self time:   0.011249

count  total (s)   self (s)
                            -- Automatically generated packer.nvim plugin loader code
                            
                            if vim.api.nvim_call_function('has', {'nvim-0.5'}) ~= 1 then
                              vim.api.nvim_command('echohl WarningMsg | echom "Invalid Neovim version for packer.nvim! | echohl None"')
                              return
                            end
                            
                            vim.api.nvim_command('packadd packer.nvim')
                            
                            local no_errors, error_msg = pcall(function()
                            
                            _G._packer = _G._packer or {}
                            _G._packer.inside_compile = true
                            
                            local time
                            local profile_info
                            local should_profile = false
                            if should_profile then
                              local hrtime = vim.loop.hrtime
                              profile_info = {}
                              time = function(chunk, start)
                                if start then
                                  profile_info[chunk] = hrtime()
                                else
                                  profile_info[chunk] = (hrtime() - profile_info[chunk]) / 1e6
                                end
                              end
                            else
                              time = function(chunk, start) end
                            end
                            
                            local function save_profiles(threshold)
                              local sorted_times = {}
                              for chunk_name, time_taken in pairs(profile_info) do
                                sorted_times[#sorted_times + 1] = {chunk_name, time_taken}
                              end
                              table.sort(sorted_times, function(a, b) return a[2] > b[2] end)
                              local results = {}
                              for i, elem in ipairs(sorted_times) do
                                if not threshold or threshold and elem[2] > threshold then
                                  results[i] = elem[1] .. ' took ' .. elem[2] .. 'ms'
                                end
                              end
                              if threshold then
                                table.insert(results, '(Only showing plugins that took longer than ' .. threshold .. ' ms ' .. 'to load)')
                              end
                            
                              _G._packer.profile_output = results
                            end
                            
                            time([[Luarocks path setup]], true)
                            local package_path_str = "/home/benk/.cache/nvim/packer_hererocks/2.1.0-beta3/share/lua/5.1/?.lua;/home/benk/.cache/nvim/packer_hererocks/2.1.0-beta3/share/lua/5.1/?/init.lua;/home/benk/.cache/nvim/packer_hererocks/2.1.0-beta3/lib/luarocks/rocks-5.1/?.lua;/home/benk/.cache/nvim/packer_hererocks/2.1.0-beta3/lib/luarocks/rocks-5.1/?/init.lua"
                            local install_cpath_pattern = "/home/benk/.cache/nvim/packer_hererocks/2.1.0-beta3/lib/lua/5.1/?.so"
                            if not string.find(package.path, package_path_str, 1, true) then
                              package.path = package.path .. ';' .. package_path_str
                            end
                            
                            if not string.find(package.cpath, install_cpath_pattern, 1, true) then
                              package.cpath = package.cpath .. ';' .. install_cpath_pattern
                            end
                            
                            time([[Luarocks path setup]], false)
                            time([[try_loadstring definition]], true)
                            local function try_loadstring(s, component, name)
                              local success, result = pcall(loadstring(s), name, _G.packer_plugins[name])
                              if not success then
                                vim.schedule(function()
                                  vim.api.nvim_notify('packer.nvim: Error running ' .. component .. ' for ' .. name .. ': ' .. result, vim.log.levels.ERROR, {})
                                end)
                              end
                              return result
                            end
                            
                            time([[try_loadstring definition]], false)
                            time([[Defining packer_plugins]], true)
                            _G.packer_plugins = {
                              catppuccin = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/catppuccin",
                                url = "https://github.com/catppuccin/nvim"
                              },
                              ["cmp-buffer"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/cmp-buffer",
                                url = "https://github.com/hrsh7th/cmp-buffer"
                              },
                              ["cmp-cmdline"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/cmp-cmdline",
                                url = "https://github.com/hrsh7th/cmp-cmdline"
                              },
                              ["cmp-nvim-lsp"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/cmp-nvim-lsp",
                                url = "https://github.com/hrsh7th/cmp-nvim-lsp"
                              },
                              ["cmp-path"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/cmp-path",
                                url = "https://github.com/hrsh7th/cmp-path"
                              },
                              ["codewindow.nvim"] = {
                                config = { "\27LJ\2\nW\0\0\3\0\4\0\b6\0\0\0'\2\1\0B\0\2\0029\1\2\0B\1\1\0019\1\3\0B\1\1\1K\0\1\0\27apply_default_keybinds\nsetup\15codewindow\frequire\0" },
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/codewindow.nvim",
                                url = "https://github.com/gorbit99/codewindow.nvim"
                              },
                              ["dressing.nvim"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/dressing.nvim",
                                url = "https://github.com/stevearc/dressing.nvim"
                              },
                              ["gitsigns.nvim"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/gitsigns.nvim",
                                url = "https://github.com/lewis6991/gitsigns.nvim"
                              },
                              ["indent-blankline.nvim"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/indent-blankline.nvim",
                                url = "https://github.com/lukas-reineke/indent-blankline.nvim"
                              },
                              ["kanagawa.nvim"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/kanagawa.nvim",
                                url = "https://github.com/rebelot/kanagawa.nvim"
                              },
                              ["leap.nvim"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/leap.nvim",
                                url = "https://github.com/ggandor/leap.nvim"
                              },
                              ["lspsaga.nvim"] = {
                                config = { "\27LJ\2\n9\0\0\3\0\3\0\a6\0\0\0'\2\1\0B\0\2\0029\0\2\0004\2\0\0B\0\2\1K\0\1\0\nsetup\flspsaga\frequire\0" },
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/lspsaga.nvim",
                                url = "https://github.com/glepnir/lspsaga.nvim"
                              },
                              ["mini.indentscope"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/mini.indentscope",
                                url = "https://github.com/echasnovski/mini.indentscope"
                              },
                              ["mini.starter"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/mini.starter",
                                url = "https://github.com/echasnovski/mini.starter"
                              },
                              nerdcommenter = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/nerdcommenter",
                                url = "https://github.com/scrooloose/nerdcommenter"
                              },
                              ["noice.nvim"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/noice.nvim",
                                url = "https://github.com/folke/noice.nvim"
                              },
                              ["nui.nvim"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/nui.nvim",
                                url = "https://github.com/MunifTanjim/nui.nvim"
                              },
                              ["nvim-bqf"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/nvim-bqf",
                                url = "https://github.com/kevinhwang91/nvim-bqf"
                              },
                              ["nvim-cmp"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/nvim-cmp",
                                url = "https://github.com/hrsh7th/nvim-cmp"
                              },
                              ["nvim-hardline"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/nvim-hardline",
                                url = "https://github.com/ojroques/nvim-hardline"
                              },
                              ["nvim-lsp-installer"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/nvim-lsp-installer",
                                url = "https://github.com/williamboman/nvim-lsp-installer"
                              },
                              ["nvim-lspconfig"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/nvim-lspconfig",
                                url = "https://github.com/neovim/nvim-lspconfig"
                              },
                              ["nvim-notify"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/nvim-notify",
                                url = "https://github.com/rcarriga/nvim-notify"
                              },
                              ["nvim-spectre"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/nvim-spectre",
                                url = "https://github.com/windwp/nvim-spectre"
                              },
                              ["nvim-treesitter"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/nvim-treesitter",
                                url = "https://github.com/nvim-treesitter/nvim-treesitter"
                              },
                              ["nvim-treesitter-context"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/nvim-treesitter-context",
                                url = "https://github.com/nvim-treesitter/nvim-treesitter-context"
                              },
                              ["nvim-web-devicons"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/nvim-web-devicons",
                                url = "https://github.com/nvim-tree/nvim-web-devicons"
                              },
                              ["packer.nvim"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/packer.nvim",
                                url = "https://github.com/wbthomason/packer.nvim"
                              },
                              ["plenary.nvim"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/plenary.nvim",
                                url = "https://github.com/nvim-lua/plenary.nvim"
                              },
                              ["smart-splits.nvim"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/smart-splits.nvim",
                                url = "https://github.com/mrjones2014/smart-splits.nvim"
                              },
                              ["telescope.nvim"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/telescope.nvim",
                                url = "https://github.com/nvim-telescope/telescope.nvim"
                              },
                              ["trouble.nvim"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/trouble.nvim",
                                url = "https://github.com/folke/trouble.nvim"
                              },
                              ["vim-fugitive"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/vim-fugitive",
                                url = "https://github.com/tpope/vim-fugitive"
                              },
                              ["vim-illuminate"] = {
                                loaded = true,
                                path = "/home/benk/.local/share/nvim/site/pack/packer/start/vim-illuminate",
                                url = "https://github.com/RRethy/vim-illuminate"
                              }
                            }
                            
                            time([[Defining packer_plugins]], false)
                            -- Config for: codewindow.nvim
                            time([[Config for codewindow.nvim]], true)
                            try_loadstring("\27LJ\2\nW\0\0\3\0\4\0\b6\0\0\0'\2\1\0B\0\2\0029\1\2\0B\1\1\0019\1\3\0B\1\1\1K\0\1\0\27apply_default_keybinds\nsetup\15codewindow\frequire\0", "config", "codewindow.nvim")
                            time([[Config for codewindow.nvim]], false)
                            -- Config for: lspsaga.nvim
                            time([[Config for lspsaga.nvim]], true)
                            try_loadstring("\27LJ\2\n9\0\0\3\0\3\0\a6\0\0\0'\2\1\0B\0\2\0029\0\2\0004\2\0\0B\0\2\1K\0\1\0\nsetup\flspsaga\frequire\0", "config", "lspsaga.nvim")
                            time([[Config for lspsaga.nvim]], false)
                            
                            _G._packer.inside_compile = false
                            if _G._packer.needs_bufread == true then
                              vim.cmd("doautocmd BufRead")
                            end
                            _G._packer.needs_bufread = false
                            
                            if should_profile then save_profiles() end
                            
                            end)
                            
                            if not no_errors then
                              error_msg = error_msg:gsub('"', '\\"')
                              vim.api.nvim_command('echohl ErrorMsg | echom "Error in packer_compiled: '..error_msg..'" | echom "Please check your config for correctness" | echohl None')
                            end

SCRIPT  /usr/share/nvim/runtime/plugin/man.lua
Sourced 1 time
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
                            if vim.g.loaded_man ~= nil then
                              return
                            end
                            vim.g.loaded_man = true
                            
                            vim.api.nvim_create_user_command('Man', function(params)
                              local man = require('man')
                              if params.bang then
                                man.init_pager()
                              else
                                local ok, err = pcall(man.open_page, params.count, params.smods, params.fargs)
                                if not ok then
                                  vim.notify(man.errormsg or err, vim.log.levels.ERROR)
                                end
                              end
                            end, {
                              bang = true,
                              bar = true,
                              addr = 'other',
                              nargs = '*',
                              complete = function(...)
                                return require('man').man_complete(...)
                              end,
                            })
                            
                            local augroup = vim.api.nvim_create_augroup('man', {})
                            
                            vim.api.nvim_create_autocmd('BufReadCmd', {
                              group = augroup,
                              pattern = 'man://*',
                              callback = function(params)
                                require('man').read_page(vim.fn.matchstr(params.match, 'man://\\zs.*'))
                              end,
                            })

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/dressing.nvim/plugin/dressing.lua
Sourced 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
                            require("dressing").patch()
                            vim.cmd([[highlight default link FloatTitle FloatBorder]])

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/indent-blankline.nvim/plugin/indent_blankline.vim
Sourced 1 time
Total time:   0.000405
 Self time:   0.000405

count  total (s)   self (s)
                            
    1              0.000014 if exists('g:loaded_indent_blankline') || !has('nvim-0.5.0')
                                finish
    1              0.000001 endif
    1              0.000005 let g:loaded_indent_blankline = 1
                            
    1              0.000004 function s:try(cmd)
                                try
                                    execute a:cmd
                                catch /E12/
                                    return
                                endtry
                            endfunction
                            
    1              0.000008 command! -bang IndentBlanklineRefresh call s:try('lua require("indent_blankline.commands").refresh("<bang>" == "!")')
    1              0.000006 command! -bang IndentBlanklineRefreshScroll call s:try('lua require("indent_blankline.commands").refresh("<bang>" == "!", true)')
    1              0.000005 command! -bang IndentBlanklineEnable call s:try('lua require("indent_blankline.commands").enable("<bang>" == "!")')
    1              0.000006 command! -bang IndentBlanklineDisable call s:try('lua require("indent_blankline.commands").disable("<bang>" == "!")')
    1              0.000005 command! -bang IndentBlanklineToggle call s:try('lua require("indent_blankline.commands").toggle("<bang>" == "!")')
                            
    1              0.000006 if exists(':IndentLinesEnable') && !g:indent_blankline_disable_warning_message
                                echohl Error
                                echom 'indent-blankline does not require IndentLine anymore, please remove it.'
                                echohl None
    1              0.000001 endif
                            
    1              0.000005 if !exists('g:__indent_blankline_setup_completed')
                                lua require("indent_blankline").setup {}
    1              0.000001 endif
                            
    1              0.000247 lua require("indent_blankline").init()
                            
    1              0.000003 augroup IndentBlanklineAutogroup
    1              0.000010     autocmd!
    1              0.000021     autocmd OptionSet list,listchars,shiftwidth,tabstop,expandtab IndentBlanklineRefresh
    1              0.000016     autocmd FileChangedShellPost,TextChanged,TextChangedI,CompleteChanged,BufWinEnter,Filetype * IndentBlanklineRefresh
    1              0.000006     autocmd WinScrolled * IndentBlanklineRefreshScroll
    1              0.000004     autocmd ColorScheme * lua require("indent_blankline.utils").reset_highlights()
    1              0.000004     autocmd VimEnter * lua require("indent_blankline").init()
    1              0.000001 augroup END
                            

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/leap.nvim/plugin/init.lua
Sourced 1 time
Total time:   0.000648
 Self time:   0.000648

count  total (s)   self (s)
                            local plug_mappings = {
                              {
                                {'n'}, '<Plug>(leap-forward-to)',
                                function ()
                                  require('leap').leap {}
                                end
                              },
                              {
                                {'x', 'o'}, '<Plug>(leap-forward-to)',
                                function ()
                                  require('leap').leap {
                                    offset = 1, inclusive_op = true, ['match-xxx*-at-the-end?'] = true
                                  }
                                end
                              },
                              {
                                {'n', 'x', 'o'}, '<Plug>(leap-forward-till)',
                                function ()
                                  require('leap').leap { offset = -1, inclusive_op = true }
                                end
                              },
                              {
                                {'n', 'x', 'o'}, '<Plug>(leap-backward-to)',
                                function ()
                                  require('leap').leap { backward = true, ['match-xxx*-at-the-end?'] = true }
                                end
                              },
                              {
                                {'n', 'x', 'o'}, '<Plug>(leap-backward-till)',
                                function ()
                                  require('leap').leap { backward = true, offset = 2 }
                                end
                              },
                              {
                                {'n', 'x', 'o'}, '<Plug>(leap-from-window)',
                                function ()
                                  require('leap').leap {
                                    target_windows = require'leap.util'.get_enterable_windows()
                                  }
                                end
                              },
                            
                              -- Deprecated mappings.
                              {
                                {'n', 'x', 'o'}, '<Plug>(leap-cross-window)',
                                function ()
                                  require('leap').leap {
                                    target_windows = require'leap.util'.get_enterable_windows()
                                  }
                                end
                              },
                              {{'n', 'x', 'o'}, '<Plug>(leap-forward)',    function () require('leap').leap {} end},
                              {{'n', 'x', 'o'}, '<Plug>(leap-backward)',   function () require('leap').leap { backward = true } end},
                              {{'n', 'x', 'o'}, '<Plug>(leap-forward-x)',  function () require('leap').leap { offset = 1, inclusive_op = true } end},
                              {{'n', 'x', 'o'}, '<Plug>(leap-backward-x)', function () require('leap').leap { backward = true, offset = 2 } end},
                            }
                            
                            for _, t in ipairs(plug_mappings) do
                              modes, lhs, rhs = unpack(t)
                              vim.keymap.set(modes, lhs, rhs, {silent = true})
                            end

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/lspsaga.nvim/plugin/lspsaga.lua
Sourced 1 time
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
                            if vim.g.lspsaga_version then
                              return
                            end
                            
                            vim.g.lspsaga_version = '0.2.7'
                            
                            vim.api.nvim_create_user_command('Lspsaga', function(args)
                              require('lspsaga.command').load_command(unpack(args.fargs))
                            end, {
                              range = true,
                              nargs = '+',
                              complete = function(arg)
                                local list = require('lspsaga.command').command_list()
                                return vim.tbl_filter(function(s)
                                  return string.match(s, '^' .. arg)
                                end, list)
                              end,
                            })
                            
                            vim.api.nvim_create_user_command('DiagnosticInsertEnable', function()
                              require('lspsaga.diagnostic'):on_insert()
                            end, {})

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/nerdcommenter/plugin/nerdcommenter.vim
Sourced 1 time
Total time:   0.002395
 Self time:   0.000391

count  total (s)   self (s)
    1              0.000011 if exists('loaded_nerd_comments')
                                finish
    1              0.000001 endif
    1              0.000003 if v:version < 700
                                echoerr "NERDCommenter: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"
                                finish
    1              0.000001 endif
    1              0.000005 let loaded_nerd_comments = 1
                            
                            " Function: s:InitVariable() function
                            " This function is used to initialise a given variable to a given value. The
                            " variable is only initialised if it does not exist prior
                            "
                            " Args:
                            "   -var: the name of the var to be initialised
                            "   -value: the value to initialise var to
                            "
                            " Returns:
                            "   0
    1              0.000004 function s:InitVariable(var, value)
                                if !exists(a:var)
                                    execute 'let ' . a:var . ' = ' . string(a:value)
                                endif
                            endfunction
                            
                            " Section: variable initialization
    1   0.000031   0.000013 call s:InitVariable('g:NERDAllowAnyVisualDelims', 1)
    1   0.000016   0.000007 call s:InitVariable('g:NERDBlockComIgnoreEmpty', 0)
    1   0.000014   0.000006 call s:InitVariable('g:NERDCommentWholeLinesInVMode', 0)
    1   0.000013   0.000006 call s:InitVariable('g:NERDCommentEmptyLines', 0)
    1   0.000012   0.000005 call s:InitVariable('g:NERDCompactSexyComs', 0)
    1   0.000013   0.000006 call s:InitVariable('g:NERDCreateDefaultMappings', 1)
    1   0.000012   0.000005 call s:InitVariable('g:NERDDefaultNesting', 1)
    1   0.000012   0.000005 call s:InitVariable('g:NERDMenuMode', 3)
    1   0.000013   0.000005 call s:InitVariable('g:NERDLPlace', '[>')
    1   0.000012   0.000005 call s:InitVariable('g:NERDUsePlaceHolders', 1)
    1   0.000012   0.000005 call s:InitVariable('g:NERDRemoveAltComs', 1)
    1   0.000012   0.000005 call s:InitVariable('g:NERDRemoveExtraSpaces', 0)
    1   0.000012   0.000005 call s:InitVariable('g:NERDRPlace', '<]')
    1   0.000012   0.000005 call s:InitVariable('g:NERDSpaceDelims', 0)
    1   0.000013   0.000005 call s:InitVariable('g:NERDDefaultAlign', 'none')
    1   0.000014   0.000006 call s:InitVariable('g:NERDTrimTrailingWhitespace', 0)
    1   0.000012   0.000005 call s:InitVariable('g:NERDToggleCheckAllLines', 0)
    1   0.000012   0.000005 call s:InitVariable('g:NERDDisableTabsInBlockComm', 0)
    1   0.000012   0.000005 call s:InitVariable('g:NERDSuppressWarnings', 0)
                            
                            " Section: Comment mapping and menu item setup
                            " ===========================================================================
                            
                            " Create menu items for the specified modes.  If a:combo is not empty, then
                            " also define mappings and show a:combo in the menu items.
    1              0.000003 function! s:CreateMaps(modes, target, desc, combo)
                                " Build up a map command like
                                " 'noremap <silent> <Plug>NERDCommenterComment :call nerdcommenter#Comment("n", "Comment")'
                                let plug = '<Plug>NERDCommenter' . a:target
                                let plug_start = 'noremap <silent> ' . plug . ' :call nerdcommenter#Comment("'
                                let plug_end = '", "' . a:target . '")<CR>'
                                " Build up a menu command like
                                " 'menu <silent> comment.Comment<Tab>\\cc <Plug>NERDCommenterComment'
                                let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment', '&Plugin.Nerd\ &Commenter'],
                                            \ g:NERDMenuMode, '')
                                let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')
                                if strlen(a:combo)
                                    let leader = exists('g:mapleader') ? g:mapleader : '\'
                                    let menu_command .= '<Tab>' . escape(leader, '\') . a:combo
                                endif
                                let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)
                                " Execute the commands built above for each requested mode.
                                for mode in (a:modes ==# '') ? [''] : split(a:modes, '\zs')
                                    if strlen(a:combo)
                                        execute mode . plug_start . mode . plug_end
                                        if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)
                                            execute mode . 'map <leader>' . a:combo . ' ' . plug
                                        endif
                                    endif
                                    " Check if the user wants the menu to be displayed.
                                    if g:NERDMenuMode !=# 0
                                        execute mode . menu_command
                                    endif
                                endfor
                            endfunction
                            
    1   0.000206   0.000010 call s:CreateMaps('nx', 'Comment',    'Comment', 'cc')
    1   0.000151   0.000011 call s:CreateMaps('nx', 'Toggle',     'Toggle', 'c<Space>')
    1   0.000139   0.000010 call s:CreateMaps('nx', 'Minimal',    'Minimal', 'cm')
    1   0.000130   0.000009 call s:CreateMaps('nx', 'Nested',     'Nested', 'cn')
    1   0.000092   0.000008 call s:CreateMaps('n',  'ToEOL',      'To EOL', 'c$')
    1   0.000126   0.000008 call s:CreateMaps('nx', 'Invert',     'Invert', 'ci')
    1   0.000125   0.000008 call s:CreateMaps('nx', 'Sexy',       'Sexy', 'cs')
    1   0.000126   0.000008 call s:CreateMaps('nx', 'Yank',       'Yank then comment', 'cy')
    1   0.000088   0.000008 call s:CreateMaps('n',  'Append',     'Append', 'cA')
    1   0.000069   0.000008 call s:CreateMaps('',   ':',          '-Sep-', '')
    1   0.000133   0.000009 call s:CreateMaps('nx', 'AlignLeft',  'Left aligned', 'cl')
    1   0.000138   0.000013 call s:CreateMaps('nx', 'AlignBoth',  'Left and right aligned', 'cb')
    1   0.000069   0.000010 call s:CreateMaps('',   ':',          '-Sep2-', '')
    1   0.000143   0.000008 call s:CreateMaps('nx', 'Uncomment',  'Uncomment', 'cu')
    1   0.000093   0.000011 call s:CreateMaps('n',  'AltDelims',  'Switch Delimiters', 'ca')
    1   0.000066   0.000008 call s:CreateMaps('i',  'Insert',     'Insert Comment Here', '')
    1   0.000063   0.000007 call s:CreateMaps('',   ':',          '-Sep3-', '')
    1   0.000063   0.000008 call s:CreateMaps('',   ':help NERDCommenterContents<CR>', 'Help', '')
                            
                            " Shim functions so old code gets passed through to the autoload functions
    1              0.000003 function! NERDComment(mode, type) range
                                if !g:NERDSuppressWarnings
                                    echom 'Function NERDComment() has been deprecated, please use nerdcommenter#Comment() instead'
                                endif
                            	if a:firstline != a:lastline
                            		echoerr "Sorry! We can't pass a range through this deprecation shim, please update your code."
                            		return v:false
                            	endif
                                return nerdcommenter#Comment(a:mode, a:type)
                            endfunction
                            
    1              0.000002 function! NERDCommentIsLineCommented(lineNo)
                                if !g:NERDSuppressWarnings
                                    echom 'Function NERDCommentIsLineCommented() has been deprecated, please use nerdcommenter#IsLineCommented() instead'
                                endif
                                return nerdcommenter#IsLineCommented(a:lineNo)
                            endfunction
                            
    1              0.000002 function! NERDCommentIsCharCommented(line, col)
                                if !g:NERDSuppressWarnings
                                    echom 'Function NERDCommentIsCharCommented() has been deprecated, please use nerdcommenter#IsCharCommented() instead'
                                endif
                                return nerdcommenter#IsCharCommented(a:line, a:col)
                            endfunction
                            
    1              0.000008 inoremap <silent> <Plug>NERDCommenterInsert <C-\><C-O>:call nerdcommenter#Comment('i', "Insert")<CR>
                            
                            " switch to/from alternative delimiters (does not use wrapper function)
    1              0.000009 nnoremap <Plug>NERDCommenterAltDelims :call nerdcommenter#SwitchToAlternativeDelimiters(1)<CR>

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/nvim-bqf/plugin/bqf.vim
Sourced 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000005 if exists('g:loaded_bqf')
                                finish
    1              0.000001 endif
                            
    1              0.000002 let g:loaded_bqf = 1
                            
    1              0.000004 com! BqfAutoToggle lua require('bqf').toggleAuto()

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/nvim-cmp/plugin/cmp.lua
Sourced 1 time
Total time:   0.000783
 Self time:   0.000783

count  total (s)   self (s)
                            if vim.g.loaded_cmp then
                              return
                            end
                            vim.g.loaded_cmp = true
                            
                            if not vim.api.nvim_create_autocmd then
                              return print('[nvim-cmp] Your nvim does not has `nvim_create_autocmd` function. Please update to latest nvim.')
                            end
                            
                            local api = require('cmp.utils.api')
                            local types = require('cmp.types')
                            local highlight = require('cmp.utils.highlight')
                            local autocmd = require('cmp.utils.autocmd')
                            
                            vim.api.nvim_set_hl(0, 'CmpItemAbbr', { link = 'CmpItemAbbrDefault', default = true })
                            vim.api.nvim_set_hl(0, 'CmpItemAbbrDeprecated', { link = 'CmpItemAbbrDeprecatedDefault', default = true })
                            vim.api.nvim_set_hl(0, 'CmpItemAbbrMatch', { link = 'CmpItemAbbrMatchDefault', default = true })
                            vim.api.nvim_set_hl(0, 'CmpItemAbbrMatchFuzzy', { link = 'CmpItemAbbrMatchFuzzyDefault', default = true })
                            vim.api.nvim_set_hl(0, 'CmpItemKind', { link = 'CmpItemKindDefault', default = true })
                            vim.api.nvim_set_hl(0, 'CmpItemMenu', { link = 'CmpItemMenuDefault', default = true })
                            for kind in pairs(types.lsp.CompletionItemKind) do
                              if type(kind) == 'string' then
                                local name = ('CmpItemKind%s'):format(kind)
                                vim.api.nvim_set_hl(0, name, { link = ('%sDefault'):format(name), default = true })
                              end
                            end
                            
                            autocmd.subscribe('ColorScheme', function()
                              highlight.inherit('CmpItemAbbrDefault', 'Pmenu', { bg = 'NONE', default = false })
                              highlight.inherit('CmpItemAbbrDeprecatedDefault', 'Comment', { bg = 'NONE', default = false })
                              highlight.inherit('CmpItemAbbrMatchDefault', 'Pmenu', { bg = 'NONE', default = false })
                              highlight.inherit('CmpItemAbbrMatchFuzzyDefault', 'Pmenu', { bg = 'NONE', default = false })
                              highlight.inherit('CmpItemKindDefault', 'Special', { bg = 'NONE', default = false })
                              highlight.inherit('CmpItemMenuDefault', 'Pmenu', { bg = 'NONE', default = false })
                              for name in pairs(types.lsp.CompletionItemKind) do
                                if type(name) == 'string' then
                                  vim.api.nvim_set_hl(0, ('CmpItemKind%sDefault'):format(name), { link = 'CmpItemKind', default = false })
                                end
                              end
                            end)
                            autocmd.emit('ColorScheme')
                            
                            if vim.on_key then
                              vim.on_key(function(keys)
                                if keys == vim.api.nvim_replace_termcodes('<C-c>', true, true, true) then
                                  vim.schedule(function()
                                    if not api.is_suitable_mode() then
                                      autocmd.emit('InsertLeave')
                                    end
                                  end)
                                end
                              end, vim.api.nvim_create_namespace('cmp.plugin'))
                            end
                            
                            vim.api.nvim_create_user_command('CmpStatus', function()
                              require('cmp').status()
                            end, { desc = 'Check status of cmp sources' })
                            
                            vim.cmd([[doautocmd <nomodeline> User CmpReady]])

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/nvim-hardline/plugin/hardline.vim
Sourced 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
                            " nvim-hardline
                            " By Olivier Roques
                            " github.com/ojroques
                            
    1              0.000006 if exists('g:loaded_hardline')
                              finish
    1              0.000001 endif
                            
    1              0.000004 let g:loaded_hardline = 1

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/nvim-lsp-installer/plugin/nvim-lsp-installer.vim
Sourced 1 time
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
    1              0.000007 if exists('g:loaded_nvim_lsp_installer') | finish | endif
    1              0.000003 let g:loaded_nvim_lsp_installer = v:true
                            
    1              0.000006 let s:save_cpo = &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000003 let s:no_confirm_flag = "--no-confirm"
                            
    1              0.000003 function! s:LspInstallCompletion(...) abort
                                return join(sort(luaeval("require'nvim-lsp-installer'.get_install_completion()")), "\n")
                            endfunction
                            
    1              0.000002 function! s:LspUninstallCompletion(...) abort
                                return join(sort(luaeval("require'nvim-lsp-installer.servers'.get_installed_server_names()")), "\n")
                            endfunction
                            
    1              0.000002 function! s:LspUninstallAllCompletion(...) abort
                                return s:no_confirm_flag
                            endfunction
                            
    1              0.000002 function! s:ParseArgs(args)
                                if len(a:args) == 0
                                    return { 'sync': v:false, 'servers': [] }
                                endif
                                let sync = a:args[0] == "--sync"
                                let servers = sync ? a:args[1:] : a:args
                                return { 'sync': sync, 'servers': servers }
                            endfunction
                            
    1              0.000002 function! s:LspInstall(args) abort
                                let parsed_args = s:ParseArgs(a:args)
                                if parsed_args.sync
                                    call luaeval("require'nvim-lsp-installer'.install_sync(_A)", parsed_args.servers)
                                else
                                    if len(parsed_args.servers) == 0
                                        call luaeval("require'nvim-lsp-installer'.install_by_filetype(_A)", &filetype)
                                    else
                                        for server_name in l:parsed_args.servers
                                            call luaeval("require'nvim-lsp-installer'.install(_A)", server_name)
                                        endfor
                                    endif
                                endif
                            endfunction
                            
    1              0.000002 function! s:LspUninstall(args) abort
                                let parsed_args = s:ParseArgs(a:args)
                                if parsed_args.sync
                                    call luaeval("require'nvim-lsp-installer'.uninstall_sync(_A)", parsed_args.servers)
                                else
                                    for server_name in l:parsed_args.servers
                                        call luaeval("require'nvim-lsp-installer'.uninstall(_A)", server_name)
                                    endfor
                                endif
                            endfunction
                            
    1              0.000002 function! s:LspUninstallAll(args) abort
                                let no_confirm = get(a:args, 0, "") == s:no_confirm_flag
                                call luaeval("require'nvim-lsp-installer'.uninstall_all(_A)", no_confirm ? v:true : v:false)
                            endfunction
                            
    1              0.000001 function! s:LspPrintInstalled() abort
                                echo luaeval("require'nvim-lsp-installer.servers'.get_installed_server_names()")
                            endfunction
                            
    1              0.000001 function! s:LspInstallInfo() abort
                                lua require'nvim-lsp-installer'.info_window.open()
                            endfunction
                            
    1              0.000001 function! s:LspInstallLog() abort
                                exe 'tabnew ' .. luaeval("require'nvim-lsp-installer.log'.outfile")
                            endfunction
                            
    1              0.000007 command! -bar -nargs=* -complete=custom,s:LspInstallCompletion      LspInstall call s:LspInstall([<f-args>])
    1              0.000005 command! -bar -nargs=+ -complete=custom,s:LspUninstallCompletion    LspUninstall call s:LspUninstall([<f-args>])
    1              0.000004 command! -bar -nargs=? -complete=custom,s:LspUninstallAllCompletion LspUninstallAll call s:LspUninstallAll([<f-args>])
                            
    1              0.000002 command! LspPrintInstalled call s:LspPrintInstalled()
    1              0.000002 command! LspInstallInfo call s:LspInstallInfo()
    1              0.000002 command! LspInstallLog call s:LspInstallLog()
                            
    1              0.000009 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/nvim-lspconfig/plugin/lspconfig.lua
Sourced 1 time
Total time:   0.000234
 Self time:   0.000234

count  total (s)   self (s)
                            local api, lsp = vim.api, vim.lsp
                            
                            if vim.g.lspconfig ~= nil then
                              return
                            end
                            vim.g.lspconfig = 1
                            
                            local version_info = vim.version()
                            if vim.fn.has 'nvim-0.7' ~= 1 then
                              local warning_str = string.format(
                                '[lspconfig] requires neovim 0.7 or later. Detected neovim version: 0.%s.%s',
                                version_info.minor,
                                version_info.patch
                              )
                              vim.notify_once(warning_str)
                              return
                            end
                            
                            local completion_sort = function(items)
                              table.sort(items)
                              return items
                            end
                            
                            local lsp_complete_configured_servers = function(arg)
                              return completion_sort(vim.tbl_filter(function(s)
                                return s:sub(1, #arg) == arg
                              end, require('lspconfig.util').available_servers()))
                            end
                            
                            local lsp_get_active_client_ids = function(arg)
                              local clients = vim.tbl_map(function(client)
                                return ('%d (%s)'):format(client.id, client.name)
                              end, require('lspconfig.util').get_managed_clients())
                            
                              return completion_sort(vim.tbl_filter(function(s)
                                return s:sub(1, #arg) == arg
                              end, clients))
                            end
                            
                            local get_clients_from_cmd_args = function(arg)
                              local result = {}
                              for id in (arg or ''):gmatch '(%d+)' do
                                result[id] = lsp.get_client_by_id(tonumber(id))
                              end
                              if vim.tbl_isempty(result) then
                                return require('lspconfig.util').get_managed_clients()
                              end
                              return vim.tbl_values(result)
                            end
                            
                            for group, hi in pairs {
                              LspInfoBorder = { link = 'Label', default = true },
                              LspInfoList = { link = 'Function', default = true },
                              LspInfoTip = { link = 'Comment', default = true },
                              LspInfoTitle = { link = 'Title', default = true },
                              LspInfoFiletype = { link = 'Type', default = true },
                            } do
                              api.nvim_set_hl(0, group, hi)
                            end
                            
                            -- Called from plugin/lspconfig.vim because it requires knowing that the last
                            -- script in scriptnames to be executed is lspconfig.
                            api.nvim_create_user_command('LspInfo', function()
                              require 'lspconfig.ui.lspinfo'()
                            end, {
                              desc = 'Displays attached, active, and configured language servers',
                            })
                            
                            api.nvim_create_user_command('LspStart', function(info)
                              local server_name = string.len(info.args) > 0 and info.args or nil
                              if server_name then
                                local config = require('lspconfig.configs')[server_name]
                                if config then
                                  config.launch()
                                  return
                                end
                              end
                            
                              local matching_configs = require('lspconfig.util').get_config_by_ft(vim.bo.filetype)
                              for _, config in ipairs(matching_configs) do
                                config.launch()
                              end
                            end, {
                              desc = 'Manually launches a language server',
                              nargs = '?',
                              complete = lsp_complete_configured_servers,
                            })
                            
                            api.nvim_create_user_command('LspRestart', function(info)
                              local detach_clients = {}
                              for _, client in ipairs(get_clients_from_cmd_args(info.args)) do
                                client.stop()
                                detach_clients[client.name] = client
                              end
                              local timer = vim.loop.new_timer()
                              timer:start(
                                500,
                                100,
                                vim.schedule_wrap(function()
                                  for client_name, client in pairs(detach_clients) do
                                    if client.is_stopped() then
                                      require('lspconfig.configs')[client_name].launch()
                                      detach_clients[client_name] = nil
                                    end
                                  end
                            
                                  if next(detach_clients) == nil and not timer:is_closing() then
                                    timer:close()
                                  end
                                end)
                              )
                            end, {
                              desc = 'Manually restart the given language client(s)',
                              nargs = '?',
                              complete = lsp_get_active_client_ids,
                            })
                            
                            api.nvim_create_user_command('LspStop', function(info)
                              local current_buf = vim.api.nvim_get_current_buf()
                              local server_id, force
                              local arguments = vim.split(info.args, '%s')
                              for _, v in pairs(arguments) do
                                if v == '++force' then
                                  force = true
                                elseif v:find '^[0-9]+$' then
                                  server_id = v
                                end
                              end
                            
                              if not server_id then
                                local servers_on_buffer = lsp.get_active_clients { bufnr = current_buf }
                                for _, client in ipairs(servers_on_buffer) do
                                  if client.attached_buffers[current_buf] then
                                    client.stop(force)
                                  end
                                end
                              else
                                for _, client in ipairs(get_clients_from_cmd_args(server_id)) do
                                  client.stop(force)
                                end
                              end
                            end, {
                              desc = 'Manually stops the given language client(s)',
                              nargs = '?',
                              complete = lsp_get_active_client_ids,
                            })
                            
                            api.nvim_create_user_command('LspLog', function()
                              vim.cmd(string.format('tabnew %s', lsp.get_log_path()))
                            end, {
                              desc = 'Opens the Nvim LSP client log.',
                            })

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/nvim-spectre/plugin/spectre.lua
Sourced 1 time
Total time:   0.008408
 Self time:   0.008408

count  total (s)   self (s)
                            local spectre = require("spectre")
                            
                            local function get_arg(str)
                            	local key, value = str:match([=[^([^%s]*)=([^%s]*)$]=])
                            
                            	-- translate string 'true' and 'false' to boolen type
                            	value = value == "true" or value
                            	value = (value == "false" and { false } or { value })[1]
                            
                            	return key, value
                            end
                            
                            vim.api.nvim_create_user_command("Spectre", function(ctx)
                            	local args = {}
                            	local user_args
                            	if #ctx.fargs == 1 or vim.tbl_isempty(ctx.fargs) then
                            		user_args = ctx.fargs[1] and ctx.fargs or { "" }
                            	elseif #ctx.fargs > 1 then
                            		user_args = ctx.fargs
                            	end
                            
                            	for _, user_arg in ipairs(user_args) do
                            		if user_arg == "%" then
                            			args["path"] = vim.fn.expand("%")
                            		elseif get_arg(user_arg) == nil then
                            			args["path"] = user_arg
                            		elseif get_arg(user_arg) then
                            			local key, value = get_arg(user_arg)
                            			args[key] = value
                            		end
                            	end
                            
                            	spectre.open(args)
                            end, {
                            	nargs = "*",
                            	complete = "file",
                            })

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/nvim-treesitter/plugin/nvim-treesitter.lua
Sourced 1 time
Total time:   0.000522
 Self time:   0.000522

count  total (s)   self (s)
                            -- Last Change: 2022 Apr 16
                            
                            if vim.g.loaded_nvim_treesitter then
                              return
                            end
                            vim.g.loaded_nvim_treesitter = true
                            
                            -- setup modules
                            require("nvim-treesitter").setup()
                            
                            local api = vim.api
                            
                            -- define autocommands
                            local augroup = api.nvim_create_augroup("NvimTreesitter", {})
                            
                            api.nvim_create_autocmd("Filetype", {
                              pattern = "query",
                              group = augroup,
                              callback = function()
                                api.nvim_clear_autocmds {
                                  group = augroup,
                                  event = "BufWritePost",
                                }
                                api.nvim_create_autocmd("BufWritePost", {
                                  group = augroup,
                                  buffer = 0,
                                  callback = function(opts)
                                    require("nvim-treesitter.query").invalidate_query_file(opts.file)
                                  end,
                                  desc = "Invalidate query file",
                                })
                              end,
                              desc = "Reload query",
                            })

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/nvim-treesitter-context/plugin/treesitter-context.vim
Sourced 1 time
Total time:   0.001406
 Self time:   0.001406

count  total (s)   self (s)
    1              0.001400 lua require'treesitter-context'

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/nvim-web-devicons/plugin/nvim-web-devicons.vim
Sourced 1 time
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    1              0.000014 if exists('g:loaded_devicons') | finish | endif
                            
    1              0.000009 let s:save_cpo = &cpo
    1              0.000009 set cpo&vim
                            
                            " TODO change so its easier to get
    1              0.000003 let g:nvim_web_devicons = 1
                            
    1              0.000008 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
    1              0.000003 let g:loaded_devicons = 1

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/plenary.nvim/plugin/plenary.vim
Sourced 1 time
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
                            
                            " Create command for running busted
    1              0.000010 command! -nargs=1 -complete=file PlenaryBustedFile
                                  \ lua require('plenary.busted').run(vim.fn.expand("<args>"))
                            
    1              0.000006 command! -nargs=+ -complete=file PlenaryBustedDirectory
                                  \ lua require('plenary.test_harness').test_directory_command("<args>")
                            
    1              0.000017 nnoremap <Plug>PlenaryTestFile :lua require('plenary.test_harness').test_directory(vim.fn.expand("%:p"))<CR>

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/smart-splits.nvim/plugin/smart-splits.lua
Sourced 1 time
Total time:   0.000126
 Self time:   0.000126

count  total (s)   self (s)
                            if vim.api.nvim_add_user_command == nil then
                              vim.cmd([[
                                " resizing
                                command! -nargs=* SmartResizeLeft :lua require('smart-splits').resize_left(<args>)<CR>
                                command! -nargs=* SmartResizeRight :lua require('smart-splits').resize_right(<args>)<CR>
                                command! -nargs=* SmartResizeUp :lua require('smart-splits').resize_up(<args>)<CR>
                                command! -nargs=* SmartResizeDown :lua require('smart-splits').resize_down(<args>)<CR>
                                " movements
                                command! -nargs=* SmartCursorMoveLeft :lua require('smart-splits').move_cursor_left(<args>)<CR>
                                command! -nargs=* SmartCursorMoveRight :lua require('smart-splits').move_cursor_right(<args>)<CR>
                                command! SmartCursorMoveUp :lua require('smart-splits').move_cursor_up()<CR>
                                command! SmartCursorMoveDown :lua require('smart-splits').move_cursor_down()<CR>
                                " persistent resize mode
                                command! SmartResizeMode :lua require('smart-splits').start_resize_mode()<CR>
                              ]])
                              return
                            end
                            
                            local function resize_handler(direction)
                              return function(args)
                                local amount
                                if args and args.args and #args.args > 0 then
                                  amount = args.args
                                end
                            
                                require('smart-splits')['resize_' .. direction](amount)
                              end
                            end
                            
                            -- resizing
                            vim.api.nvim_add_user_command('SmartResizeLeft', resize_handler('left'), { desc = '"Smart" resize left', nargs = '*' })
                            vim.api.nvim_add_user_command(
                              'SmartResizeRight',
                              resize_handler('right'),
                              { desc = '"Smart" resize right', nargs = '*' }
                            )
                            vim.api.nvim_add_user_command('SmartResizeUp', resize_handler('up'), { desc = '"Smart" resize up', nargs = '*' })
                            vim.api.nvim_add_user_command('SmartResizeDown', resize_handler('down'), { desc = '"Smart" resize down', nargs = '*' })
                            
                            local function move_handler(direction)
                              return function(args)
                                local same_row
                                if args and args.args and #args.args > 0 then
                                  same_row = args.args
                                end
                                require('smart-splits')['move_cursor_' .. direction](same_row)
                              end
                            end
                            
                            -- movements
                            vim.api.nvim_add_user_command(
                              'SmartCursorMoveLeft',
                              move_handler('left'),
                              { desc = '"Smart" resize left', nargs = '*' }
                            )
                            vim.api.nvim_add_user_command(
                              'SmartCursorMoveRight',
                              move_handler('right'),
                              { desc = '"Smart" resize right', nargs = '*' }
                            )
                            vim.api.nvim_add_user_command(
                              'SmartCursorMoveUp',
                              require('smart-splits').move_cursor_up,
                              { desc = '"Smart" resize up' }
                            )
                            vim.api.nvim_add_user_command(
                              'SmartCursorMoveDown',
                              require('smart-splits').move_cursor_down,
                              { desc = '"Smart" resize down' }
                            )
                            
                            -- persistent resize mode
                            vim.api.nvim_add_user_command(
                              'SmartResizeMode',
                              require('smart-splits').start_resize_mode,
                              { desc = 'Start persistent resize mode, press <ESC> to exit resize mode' }
                            )

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/telescope.nvim/plugin/telescope.lua
Sourced 1 time
Total time:   0.000411
 Self time:   0.000411

count  total (s)   self (s)
                            if 1 ~= vim.fn.has "nvim-0.7.0" then
                              vim.api.nvim_err_writeln "Telescope.nvim requires at least nvim-0.7.0. See `:h telescope.changelog-1851`"
                              return
                            end
                            
                            if vim.g.loaded_telescope == 1 then
                              return
                            end
                            vim.g.loaded_telescope = 1
                            
                            local highlights = {
                              -- Sets the highlight for selected items within the picker.
                              TelescopeSelection = { default = true, link = "Visual" },
                              TelescopeSelectionCaret = { default = true, link = "TelescopeSelection" },
                              TelescopeMultiSelection = { default = true, link = "Type" },
                              TelescopeMultiIcon = { default = true, link = "Identifier" },
                            
                              -- "Normal" in the floating windows created by telescope.
                              TelescopeNormal = { default = true, link = "Normal" },
                              TelescopePreviewNormal = { default = true, link = "TelescopeNormal" },
                              TelescopePromptNormal = { default = true, link = "TelescopeNormal" },
                              TelescopeResultsNormal = { default = true, link = "TelescopeNormal" },
                            
                              -- Border highlight groups.
                              --   Use TelescopeBorder to override the default.
                              --   Otherwise set them specifically
                              TelescopeBorder = { default = true, link = "TelescopeNormal" },
                              TelescopePromptBorder = { default = true, link = "TelescopeBorder" },
                              TelescopeResultsBorder = { default = true, link = "TelescopeBorder" },
                              TelescopePreviewBorder = { default = true, link = "TelescopeBorder" },
                            
                              -- Title highlight groups.
                              --   Use TelescopeTitle to override the default.
                              --   Otherwise set them specifically
                              TelescopeTitle = { default = true, link = "TelescopeBorder" },
                              TelescopePromptTitle = { default = true, link = "TelescopeTitle" },
                              TelescopeResultsTitle = { default = true, link = "TelescopeTitle" },
                              TelescopePreviewTitle = { default = true, link = "TelescopeTitle" },
                            
                              TelescopePromptCounter = { default = true, link = "NonText" },
                            
                              -- Used for highlighting characters that you match.
                              TelescopeMatching = { default = true, link = "Special" },
                            
                              -- Used for the prompt prefix
                              TelescopePromptPrefix = { default = true, link = "Identifier" },
                            
                              -- Used for highlighting the matched line inside Previewer. Works only for (vim_buffer_ previewer)
                              TelescopePreviewLine = { default = true, link = "Visual" },
                              TelescopePreviewMatch = { default = true, link = "Search" },
                            
                              TelescopePreviewPipe = { default = true, link = "Constant" },
                              TelescopePreviewCharDev = { default = true, link = "Constant" },
                              TelescopePreviewDirectory = { default = true, link = "Directory" },
                              TelescopePreviewBlock = { default = true, link = "Constant" },
                              TelescopePreviewLink = { default = true, link = "Special" },
                              TelescopePreviewSocket = { default = true, link = "Statement" },
                              TelescopePreviewRead = { default = true, link = "Constant" },
                              TelescopePreviewWrite = { default = true, link = "Statement" },
                              TelescopePreviewExecute = { default = true, link = "String" },
                              TelescopePreviewHyphen = { default = true, link = "NonText" },
                              TelescopePreviewSticky = { default = true, link = "Keyword" },
                              TelescopePreviewSize = { default = true, link = "String" },
                              TelescopePreviewUser = { default = true, link = "Constant" },
                              TelescopePreviewGroup = { default = true, link = "Constant" },
                              TelescopePreviewDate = { default = true, link = "Directory" },
                              TelescopePreviewMessage = { default = true, link = "TelescopePreviewNormal" },
                              TelescopePreviewMessageFillchar = { default = true, link = "TelescopePreviewMessage" },
                            
                              -- Used for Picker specific Results highlighting
                              TelescopeResultsClass = { default = true, link = "Function" },
                              TelescopeResultsConstant = { default = true, link = "Constant" },
                              TelescopeResultsField = { default = true, link = "Function" },
                              TelescopeResultsFunction = { default = true, link = "Function" },
                              TelescopeResultsMethod = { default = true, link = "Method" },
                              TelescopeResultsOperator = { default = true, link = "Operator" },
                              TelescopeResultsStruct = { default = true, link = "Struct" },
                              TelescopeResultsVariable = { default = true, link = "SpecialChar" },
                            
                              TelescopeResultsLineNr = { default = true, link = "LineNr" },
                              TelescopeResultsIdentifier = { default = true, link = "Identifier" },
                              TelescopeResultsNumber = { default = true, link = "Number" },
                              TelescopeResultsComment = { default = true, link = "Comment" },
                              TelescopeResultsSpecialComment = { default = true, link = "SpecialComment" },
                            
                              -- Used for git status Results highlighting
                              TelescopeResultsDiffChange = { default = true, link = "DiffChange" },
                              TelescopeResultsDiffAdd = { default = true, link = "DiffAdd" },
                              TelescopeResultsDiffDelete = { default = true, link = "DiffDelete" },
                              TelescopeResultsDiffUntracked = { default = true, link = "NonText" },
                            }
                            
                            for k, v in pairs(highlights) do
                              vim.api.nvim_set_hl(0, k, v)
                            end
                            
                            -- This is like "<C-R>" in your terminal.
                            --     To use it, do `cmap <C-R> <Plug>(TelescopeFuzzyCommandSearch)
                            vim.keymap.set(
                              "c",
                              "<Plug>(TelescopeFuzzyCommandSearch)",
                              "<C-\\>e \"lua require('telescope.builtin').command_history "
                                .. '{ default_text = [=[" . escape(getcmdline(), \'"\') . "]=] }"<CR><CR>',
                              { silent = true, noremap = true }
                            )
                            
                            vim.api.nvim_create_user_command("Telescope", function(opts)
                              require("telescope.command").load_command(unpack(opts.fargs))
                            end, {
                              nargs = "*",
                              complete = function(_, line)
                                local builtin_list = vim.tbl_keys(require "telescope.builtin")
                                local extensions_list = vim.tbl_keys(require("telescope._extensions").manager)
                            
                                local l = vim.split(line, "%s+")
                                local n = #l - 2
                            
                                if n == 0 then
                                  return vim.tbl_filter(function(val)
                                    return vim.startswith(val, l[2])
                                  end, vim.tbl_extend("force", builtin_list, extensions_list))
                                end
                            
                                if n == 1 then
                                  local is_extension = vim.tbl_filter(function(val)
                                    return val == l[2]
                                  end, extensions_list)
                            
                                  if #is_extension > 0 then
                                    local extensions_subcommand_dict = require("telescope.command").get_extensions_subcommand()
                                    return vim.tbl_filter(function(val)
                                      return vim.startswith(val, l[3])
                                    end, extensions_subcommand_dict[l[2]])
                                  end
                                end
                            
                                local options_list = vim.tbl_keys(require("telescope.config").values)
                                return vim.tbl_filter(function(val)
                                  return vim.startswith(val, l[#l])
                                end, options_list)
                              end,
                            })

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/trouble.nvim/plugin/trouble.vim
Sourced 1 time
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
                            
    1              0.000004 augroup Trouble
    1              0.000015   autocmd!
    1              0.000008   if has('nvim-0.6')
                                " Use the new diagnostic subsystem for neovim 0.6 and up
    1              0.000005     au DiagnosticChanged * lua require'trouble'.refresh({auto = true, provider = "diagnostics"})
                              else
                                au User LspDiagnosticsChanged lua require'trouble'.refresh({auto = true, provider = "diagnostics"})
    1              0.000001   endif
    1              0.000006   autocmd BufWinEnter,BufEnter * lua require("trouble").action("on_win_enter")
    1              0.000001 augroup end
                            
    1              0.000006 function! s:complete(arg,line,pos) abort
                              return join(sort(luaeval('vim.tbl_keys(require("trouble.providers").providers)')), "\n")
                            endfunction
                            
    1              0.000008 command! -nargs=* -complete=custom,s:complete Trouble lua require'trouble'.open(<f-args>)
    1              0.000004 command! -nargs=* -complete=custom,s:complete TroubleToggle lua require'trouble'.toggle(<f-args>)
    1              0.000003 command! TroubleClose lua require'trouble'.close()
    1              0.000003 command! TroubleRefresh lua require'trouble'.refresh()
                            

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/vim-fugitive/plugin/fugitive.vim
Sourced 1 time
Total time:   0.001373
 Self time:   0.001244

count  total (s)   self (s)
                            " fugitive.vim - A Git wrapper so awesome, it should be illegal
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            " Version:      3.7
                            " GetLatestVimScripts: 2975 1 :AutoInstall: fugitive.vim
                            
    1              0.000005 if exists('g:loaded_fugitive')
                              finish
    1              0.000001 endif
    1              0.000004 let g:loaded_fugitive = 1
                            
    1              0.000002 let s:bad_git_dir = '/$\|^fugitive:'
                            
                            " FugitiveGitDir() returns the detected Git dir for the given buffer number,
                            " or the current buffer if no argument is passed.  This will be an empty
                            " string if no Git dir was found.  Use !empty(FugitiveGitDir()) to check if
                            " Fugitive is active in the current buffer.  Do not rely on this for direct
                            " filesystem access; use FugitiveFind('.git/whatever') instead.
    1              0.000002 function! FugitiveGitDir(...) abort
                              if v:version < 704
                                return ''
                              elseif !a:0 || type(a:1) == type(0) && a:1 < 0 || a:1 is# get(v:, 'true', -1)
                                if exists('g:fugitive_event')
                                  return g:fugitive_event
                                endif
                                let dir = get(b:, 'git_dir', '')
                                if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|terminal\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
                                elseif (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && &buftype =~# '^\%(nowrite\)\=$'
                                  let b:git_dir = FugitiveExtractGitDir(bufnr(''))
                                  return b:git_dir
                                endif
                                return dir =~# s:bad_git_dir ? '' : dir
                              elseif type(a:1) == type(0) && a:1 isnot# 0
                                if a:1 == bufnr('') && (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && &buftype =~# '^\%(nowrite\)\=$'
                                  let b:git_dir = FugitiveExtractGitDir(a:1)
                                endif
                                let dir = getbufvar(a:1, 'git_dir')
                                return dir =~# s:bad_git_dir ? '' : dir
                              elseif type(a:1) == type('')
                                return substitute(s:Slash(a:1), '/$', '', '')
                              elseif type(a:1) == type({})
                                return get(a:1, 'fugitive_dir', get(a:1, 'git_dir', ''))
                              else
                                return ''
                              endif
                            endfunction
                            
                            " FugitiveReal() takes a fugitive:// URL and returns the corresponding path in
                            " the work tree.  This may be useful to get a cleaner path for inclusion in
                            " the statusline, for example.  Note that the file and its parent directories
                            " are not guaranteed to exist.
                            "
                            " This is intended as an abstract API to be used on any "virtual" path.  For a
                            " buffer named foo://bar, check for a function named FooReal(), and if it
                            " exists, call FooReal("foo://bar").
    1              0.000001 function! FugitiveReal(...) abort
                              let file = a:0 ? a:1 : @%
                              if type(file) ==# type({})
                                let dir = FugitiveGitDir(file)
                                let tree = s:Tree(dir)
                                return s:VimSlash(empty(tree) ? dir : tree)
                              elseif file =~# '^\a\a\+:' || a:0 > 1
                                return call('fugitive#Real', [file] + a:000[1:-1])
                              elseif file =~# '^/\|^\a:\|^$'
                                return file
                              else
                                return fnamemodify(file, ':p' . (file =~# '[\/]$' ? '' : ':s?[\/]$??'))
                              endif
                            endfunction
                            
                            " FugitiveFind() takes a Fugitive object and returns the appropriate Vim
                            " buffer name.  You can use this to generate Fugitive URLs ("HEAD:README") or
                            " to get the absolute path to a file in the Git dir (".git/HEAD"), the common
                            " dir (".git/config"), or the work tree (":(top)Makefile").
                            "
                            " An optional second argument provides the Git dir, or the buffer number of a
                            " buffer with a Git dir.  The default is the current buffer.
    1              0.000001 function! FugitiveFind(...) abort
                              if a:0 && (type(a:1) ==# type({}) || type(a:1) ==# type(0))
                                return call('fugitive#Find', a:000[1:-1] + [FugitiveGitDir(a:1)])
                              else
                                return fugitive#Find(a:0 ? a:1 : bufnr(''), FugitiveGitDir(a:0 > 1 ? a:2 : -1))
                              endif
                            endfunction
                            
                            " FugitiveParse() takes a fugitive:// URL and returns a 2 element list
                            " containing an object name ("commit:file") and the Git dir.  It's effectively
                            " the inverse of FugitiveFind().
    1              0.000001 function! FugitiveParse(...) abort
                              let path = s:Slash(a:0 ? a:1 : @%)
                              if path !~# '^fugitive://'
                                return ['', '']
                              endif
                              let [rev, dir] = fugitive#Parse(path)
                              if !empty(dir)
                                return [rev, dir]
                              endif
                              throw 'fugitive: invalid Fugitive URL ' . path
                            endfunction
                            
                            " FugitiveGitVersion() queries the version of Git in use.  Pass up to 3
                            " arguments to return a Boolean of whether a certain minimum version is
                            " available (FugitiveGitVersion(2,3,4) checks for 2.3.4 or higher) or no
                            " arguments to get a raw string.
    1              0.000001 function! FugitiveGitVersion(...) abort
                              return call('fugitive#GitVersion', a:000)
                            endfunction
                            
                            " FugitiveResult() returns an object encapsulating the result of the most
                            " recent :Git command.  Will be empty if no result is available.  During a
                            " User FugitiveChanged event, this is guaranteed to correspond to the :Git
                            " command that triggered the event, or be empty if :Git was not the trigger.
                            " Pass in the name of a temp buffer to get the result object for that command
                            " instead.  Contains the following keys:
                            "
                            " * "args": List of command arguments, starting with the subcommand.  Will be
                            "   empty for usages like :Git --help.
                            " * "git_dir": Git dir of the relevant repository.
                            " * "exit_status": The integer exit code of the process.
                            " * "flags": Flags passed directly to Git, like -c and --help.
                            " * "file": Path to file containing command output.  Not guaranteed to exist,
                            "   so verify with filereadable() before trying to access it.
    1              0.000001 function! FugitiveResult(...) abort
                              return call('fugitive#Result', a:000)
                            endfunction
                            
                            " FugitiveExecute() runs Git with a list of arguments and returns a dictionary
                            " with the following keys:
                            "
                            " * "exit_status": The integer exit code of the process.
                            " * "stdout": The stdout produced by the process, as a list of lines.
                            " * "stderr": The stdout produced by the process, as a list of lines.
                            "
                            " An optional second argument provides the Git dir, or the buffer number of a
                            " buffer with a Git dir.  The default is the current buffer.
                            "
                            " An optional final argument is a callback Funcref, for asynchronous
                            " execution.
    1              0.000002 function! FugitiveExecute(args, ...) abort
                              return call('fugitive#Execute', [a:args] + a:000)
                            endfunction
                            
                            " FugitiveShellCommand() turns an array of arguments into a Git command string
                            " which can be executed with functions like system() and commands like :!.
                            " Integer arguments will be treated as buffer numbers, and the appropriate
                            " relative path inserted in their place.
                            "
                            " An optional second argument provides the Git dir, or the buffer number of a
                            " buffer with a Git dir.  The default is the current buffer.
    1              0.000001 function! FugitiveShellCommand(...) abort
                              return call('fugitive#ShellCommand', a:000)
                            endfunction
                            
                            " FugitiveConfig() get returns an opaque structure that can be passed to other
                            " FugitiveConfig functions in lieu of a Git directory.  This can be faster
                            " when performing multiple config queries.  Do not rely on the internal
                            " structure of the return value as it is not guaranteed.  If you want a full
                            " dictionary of every config value, use FugitiveConfigGetRegexp('.*').
                            "
                            " An optional argument provides the Git dir, or the buffer number of a
                            " buffer with a Git dir.  The default is the current buffer.  Pass a blank
                            " string to limit to the global config.
    1              0.000001 function! FugitiveConfig(...) abort
                              return call('fugitive#Config', a:000)
                            endfunction
                            
                            " FugitiveConfigGet() retrieves a Git configuration value.  An optional second
                            " argument can be either the object returned by FugitiveConfig(), or a Git
                            " dir or buffer number to be passed along to FugitiveConfig().
    1              0.000001 function! FugitiveConfigGet(name, ...) abort
                              return get(call('FugitiveConfigGetAll', [a:name] + (a:0 ? [a:1] : [])), 0, get(a:, 2, ''))
                            endfunction
                            
                            " FugitiveConfigGetAll() is like FugitiveConfigGet() but returns a list of
                            " all values.
    1              0.000001 function! FugitiveConfigGetAll(name, ...) abort
                              return call('fugitive#ConfigGetAll', [a:name] + a:000)
                            endfunction
                            
                            " FugitiveConfigGetRegexp() retrieves a dictionary of all configuration values
                            " with a key matching the given pattern.  Like git config --get-regexp, but
                            " using a Vim regexp.  Second argument has same semantics as
                            " FugitiveConfigGet().
    1              0.000002 function! FugitiveConfigGetRegexp(pattern, ...) abort
                              return call('fugitive#ConfigGetRegexp', [a:pattern] + a:000)
                            endfunction
                            
                            " FugitiveRemoteUrl() retrieves the remote URL for the given remote name,
                            " defaulting to the current branch's remote or "origin" if no argument is
                            " given.  Similar to `git remote get-url`, but also attempts to resolve HTTP
                            " redirects and SSH host aliases.
                            "
                            " An optional second argument provides the Git dir, or the buffer number of a
                            " buffer with a Git dir.  The default is the current buffer.
    1              0.000001 function! FugitiveRemoteUrl(...) abort
                              return call('fugitive#RemoteUrl', a:000)
                            endfunction
                            
                            " FugitiveRemote() returns a data structure parsed from the remote URL.
                            " For example, for remote URL "https://me@example.com:1234/repo.git", the
                            " returned dictionary will contain the following:
                            "
                            " * "scheme": "https"
                            " * "authority": "user@example.com:1234"
                            " * "path": "/repo.git" (for SSH URLs this may be a relative path)
                            " * "pathname": "/repo.git" (always coerced to absolute path)
                            " * "host": "example.com:1234"
                            " * "hostname": "example.com"
                            " * "port": "1234"
                            " * "user": "me"
                            " * "path": "/repo.git"
                            " * "url": "https://me@example.com:1234/repo.git"
    1              0.000001 function! FugitiveRemote(...) abort
                              return call('fugitive#Remote', a:000)
                            endfunction
                            
                            " FugitiveDidChange() triggers a FugitiveChanged event and reloads the summary
                            " buffer for the current or given buffer number's repository.  You can also
                            " give the result of a FugitiveExecute() and that context will be made
                            " available inside the FugitiveChanged() event.
                            "
                            " Passing the special argument 0 (the number zero) softly expires summary
                            " buffers for all repositories.  This can be used after a call to system()
                            " with unclear implications.
    1              0.000001 function! FugitiveDidChange(...) abort
                              return call('fugitive#DidChange', a:000)
                            endfunction
                            
                            " FugitiveHead() retrieves the name of the current branch. If the current HEAD
                            " is detached, FugitiveHead() will return the empty string, unless the
                            " optional argument is given, in which case the hash of the current commit
                            " will be truncated to the given number of characters.
                            "
                            " An optional second argument provides the Git dir, or the buffer number of a
                            " buffer with a Git dir.  The default is the current buffer.
    1              0.000001 function! FugitiveHead(...) abort
                              if a:0 && (type(a:1) ==# type({}) || type(a:1) ==# type('') && a:1 !~# '^\d\+$')
                                let dir = FugitiveGitDir(a:1)
                                let arg = get(a:, 2, 0)
                              elseif a:0 > 1
                                let dir = FugitiveGitDir(a:2)
                                let arg = a:1
                              else
                                let dir = FugitiveGitDir()
                                let arg = get(a:, 1, 0)
                              endif
                              if empty(dir)
                                return ''
                              endif
                              return fugitive#Head(arg, dir)
                            endfunction
                            
    1              0.000001 function! FugitivePath(...) abort
                              if a:0 > 2 && type(a:1) ==# type({})
                                return fugitive#Path(a:2, a:3, FugitiveGitDir(a:1))
                              elseif a:0 && type(a:1) ==# type({})
                                return FugitiveReal(a:0 > 1 ? a:2 : @%)
                              elseif a:0 > 1
                                return fugitive#Path(a:1, a:2, FugitiveGitDir(a:0 > 2 ? a:3 : -1))
                              else
                                return FugitiveReal(a:0 ? a:1 : @%)
                              endif
                            endfunction
                            
    1              0.000001 function! FugitiveStatusline(...) abort
                              if empty(FugitiveGitDir(bufnr('')))
                                return ''
                              endif
                              return fugitive#Statusline()
                            endfunction
                            
    1              0.000004 let s:resolved_git_dirs = {}
    1              0.000001 function! FugitiveActualDir(...) abort
                              let dir = call('FugitiveGitDir', a:000)
                              if empty(dir)
                                return ''
                              endif
                              if !has_key(s:resolved_git_dirs, dir)
                                let s:resolved_git_dirs[dir] = s:ResolveGitDir(dir)
                              endif
                              return empty(s:resolved_git_dirs[dir]) ? dir : s:resolved_git_dirs[dir]
                            endfunction
                            
    1              0.000002 let s:commondirs = {}
    1              0.000001 function! FugitiveCommonDir(...) abort
                              let dir = call('FugitiveActualDir', a:000)
                              if empty(dir)
                                return ''
                              endif
                              if has_key(s:commondirs, dir)
                                return s:commondirs[dir]
                              endif
                              if getfsize(dir . '/HEAD') >= 10
                                let cdir = get(s:ReadFile(dir . '/commondir', 1), 0, '')
                                if cdir =~# '^/\|^\a:/'
                                  let s:commondirs[dir] = s:Slash(FugitiveVimPath(cdir))
                                elseif len(cdir)
                                  let s:commondirs[dir] = simplify(dir . '/' . cdir)
                                else
                                  let s:commondirs[dir] = dir
                                endif
                              else
                                let s:commondirs[dir] = dir
                              endif
                              return s:commondirs[dir]
                            endfunction
                            
    1              0.000001 function! FugitiveWorkTree(...) abort
                              let tree = s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))
                              if tree isnot# 0 || a:0 > 1
                                return tree
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000001 function! FugitiveIsGitDir(...) abort
                              if !a:0 || type(a:1) !=# type('')
                                return !empty(call('FugitiveGitDir', a:000))
                              endif
                              let path = substitute(a:1, '[\/]$', '', '') . '/'
                              return len(path) && getfsize(path.'HEAD') > 10 && (
                                    \ isdirectory(path.'objects') && isdirectory(path.'refs') ||
                                    \ getftype(path.'commondir') ==# 'file')
                            endfunction
                            
    1              0.000002 function! s:ReadFile(path, line_count) abort
                              if v:version < 800 && !filereadable(a:path)
                                return []
                              endif
                              try
                                return readfile(a:path, 'b', a:line_count)
                              catch
                                return []
                              endtry
                            endfunction
                            
    1              0.000002 let s:worktree_for_dir = {}
    1              0.000002 let s:dir_for_worktree = {}
    1              0.000002 function! s:Tree(path) abort
                              if a:path =~# '/\.git$'
                                return len(a:path) ==# 5 ? '/' : a:path[0:-6]
                              elseif a:path ==# ''
                                return ''
                              endif
                              let dir = FugitiveActualDir(a:path)
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let ext_wtc_pat = 'v:val =~# "^\\s*worktreeConfig *= *\\%(true\\|yes\\|on\\|1\\) *$"'
                                let config = s:ReadFile(dir . '/config', 50)
                                if len(config)
                                  let ext_wtc_config = filter(copy(config), ext_wtc_pat)
                                  if len(ext_wtc_config) == 1 && filereadable(dir . '/config.worktree')
                                     let config += s:ReadFile(dir . '/config.worktree', 50)
                                  endif
                                else
                                  let worktree = fnamemodify(FugitiveVimPath(get(s:ReadFile(dir . '/gitdir', 1), '0', '')), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                  if len(filter(s:ReadFile(FugitiveCommonDir(dir) . '/config', 50), ext_wtc_pat))
                                    let config = s:ReadFile(dir . '/config.worktree', 50)
                                  endif
                                endif
                                if len(config)
                                  let wt_config = filter(copy(config), 'v:val =~# "^\\s*worktree *="')
                                  if len(wt_config)
                                    let worktree = FugitiveVimPath(matchstr(wt_config[0], '= *\zs.*'))
                                  elseif !exists('worktree')
                                    call filter(config,'v:val =~# "^\\s*bare *= *true *$"')
                                    if empty(config)
                                      let s:worktree_for_dir[dir] = 0
                                    endif
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif
                            endfunction
                            
    1              0.000002 function! s:CeilingDirectories() abort
                              if !exists('s:ceiling_directories')
                                let s:ceiling_directories = []
                                let resolve = 1
                                for dir in split($GIT_CEILING_DIRECTORIES, has('win32') ? ';' : ':', 1)
                                  if empty(dir)
                                    let resolve = 0
                                  elseif resolve
                                    call add(s:ceiling_directories, s:Slash(resolve(dir)))
                                  else
                                    call add(s:ceiling_directories, s:Slash(dir))
                                  endif
                                endfor
                              endif
                              return s:ceiling_directories + get(g:, 'ceiling_directories', [s:Slash(fnamemodify(expand('~'), ':h'))])
                            endfunction
                            
    1              0.000002 function! s:ResolveGitDir(git_dir) abort
                              let type = getftype(a:git_dir)
                              if type ==# 'dir' && FugitiveIsGitDir(a:git_dir)
                                return a:git_dir
                              elseif type ==# 'link' && FugitiveIsGitDir(a:git_dir)
                                return resolve(a:git_dir)
                              elseif type !=# ''
                                let line = get(s:ReadFile(a:git_dir, 1), 0, '')
                                let file_dir = s:Slash(FugitiveVimPath(matchstr(line, '^gitdir: \zs.*')))
                                if file_dir !~# '^/\|^\a:\|^$' && a:git_dir =~# '/\.git$' && FugitiveIsGitDir(a:git_dir[0:-5] . file_dir)
                                  return simplify(a:git_dir[0:-5] . file_dir)
                                elseif file_dir =~# '^/\|^\a:' && FugitiveIsGitDir(file_dir)
                                  return file_dir
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! FugitiveExtractGitDir(path) abort
                              if type(a:path) ==# type({})
                                return get(a:path, 'fugitive_dir', get(a:path, 'git_dir', ''))
                              elseif type(a:path) == type(0)
                                let path = s:Slash(a:path > 0 ? bufname(a:path) : bufname(''))
                              else
                                let path = s:Slash(a:path)
                              endif
                              if path =~# '^fugitive://'
                                return fugitive#Parse(path)[1]
                              elseif empty(path)
                                return ''
                              endif
                              let pre = substitute(matchstr(path, '^\a\a\+\ze:'), '^.', '\u&', '')
                              if len(pre) && exists('*' . pre . 'Real')
                                let path = {pre}Real(path)
                              endif
                              let root = s:Slash(fnamemodify(path, ':p:h'))
                              let previous = ""
                              let env_git_dir = len($GIT_DIR) ? s:Slash(simplify(fnamemodify(FugitiveVimPath($GIT_DIR), ':p:s?[\/]$??'))) : ''
                              call s:Tree(env_git_dir)
                              let ceiling_directories = s:CeilingDirectories()
                              while root !=# previous && root !~# '^$\|^//[^/]*$'
                                if index(ceiling_directories, root) >= 0
                                  break
                                endif
                                if root ==# $GIT_WORK_TREE && FugitiveIsGitDir(env_git_dir)
                                  return env_git_dir
                                elseif has_key(s:dir_for_worktree, root)
                                  return s:dir_for_worktree[root]
                                endif
                                let dir = substitute(root, '[\/]$', '', '') . '/.git'
                                let resolved = s:ResolveGitDir(dir)
                                if !empty(resolved)
                                  let s:resolved_git_dirs[dir] = resolved
                                  return dir is# resolved || s:Tree(resolved) is# 0 ? dir : resolved
                                elseif FugitiveIsGitDir(root)
                                  let s:resolved_git_dirs[root] = root
                                  return root
                                endif
                                let previous = root
                                let root = fnamemodify(root, ':h')
                              endwhile
                              return ''
                            endfunction
                            
    1              0.000001 function! FugitiveDetect(...) abort
                              if v:version < 704
                                return ''
                              endif
                              if exists('b:git_dir') && b:git_dir =~# '^$\|' . s:bad_git_dir
                                unlet b:git_dir
                              endif
                              if !exists('b:git_dir')
                                let b:git_dir = FugitiveExtractGitDir(a:0 ? a:1 : bufnr(''))
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! FugitiveGitPath(path) abort
                              return s:Slash(a:path)
                            endfunction
                            
    1              0.000004 if exists('+shellslash')
                            
                              function! s:Slash(path) abort
                                return tr(a:path, '\', '/')
                              endfunction
                            
                              function! s:VimSlash(path) abort
                                return tr(a:path, '\/', &shellslash ? '//' : '\\')
                              endfunction
                            
                              function FugitiveVimPath(path) abort
                                return tr(a:path, '\/', &shellslash ? '//' : '\\')
                              endfunction
                            
    1              0.000001 else
                            
    1              0.000001   function! s:Slash(path) abort
                                return a:path
                              endfunction
                            
    1              0.000001   function! s:VimSlash(path) abort
                                return a:path
                              endfunction
                            
    1              0.000006   if has('win32unix') && filereadable('/git-bash.exe')
                                function! FugitiveVimPath(path) abort
                                  return substitute(a:path, '^\(\a\):', '/\l\1', '')
                                endfunction
    1              0.000001   else
    1              0.000001     function! FugitiveVimPath(path) abort
                                  return a:path
                                endfunction
    1              0.000001   endif
                            
    1              0.000001 endif
                            
    1              0.000002 function! s:ProjectionistDetect() abort
                              let file = s:Slash(get(g:, 'projectionist_file', ''))
                              let dir = FugitiveExtractGitDir(file)
                              let base = matchstr(file, '^fugitive://.\{-\}//\x\+')
                              if empty(base)
                                let base = s:Tree(dir)
                              endif
                              if !empty(base)
                                if exists('+shellslash') && !&shellslash
                                  let base = tr(base, '/', '\')
                                endif
                                let file = FugitiveFind('.git/info/projections.json', dir)
                                if filereadable(file)
                                  call projectionist#append(base, file)
                                endif
                              endif
                            endfunction
                            
    1              0.000008 let s:addr_other = has('patch-8.1.560') || has('nvim-0.5.0') ? '-addr=other' : ''
    1              0.000005 let s:addr_tabs  = has('patch-7.4.542') ? '-addr=tabs' : ''
    1              0.000004 let s:addr_wins  = has('patch-7.4.542') ? '-addr=windows' : ''
                            
    1              0.000005 if exists(':G') != 2
    1              0.000013   command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#Complete G   exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
    1              0.000001 endif
    1              0.000011 command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#Complete Git exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
                            
    1              0.000007 if exists(':Gstatus') != 2 && get(g:, 'fugitive_legacy_commands', 0)
                              exe 'command! -bang -bar     -range=-1' s:addr_other 'Gstatus exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                                    \ '|echohl WarningMSG|echomsg ":Gstatus is deprecated in favor of :Git (with no arguments)"|echohl NONE'
    1              0.000001 endif
                            
    9              0.000015 for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
    8              0.000040   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
                                exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd)
                                      \ 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|'
                                      \ 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
    8              0.000004   endif
    9              0.000006 endfor
    1              0.000003 unlet s:cmd
                            
    1              0.000010 exe "command! -bar -bang -nargs=? -complete=customlist,fugitive#CdComplete Gcd  exe fugitive#Cd(<q-args>, 0)"
    1              0.000005 exe "command! -bar -bang -nargs=? -complete=customlist,fugitive#CdComplete Glcd exe fugitive#Cd(<q-args>, 1)"
                            
    1              0.000017 exe 'command! -bang -nargs=? -range=-1' s:addr_wins '-complete=customlist,fugitive#GrepComplete Ggrep  exe fugitive#GrepCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000016 exe 'command! -bang -nargs=? -range=-1' s:addr_wins '-complete=customlist,fugitive#GrepComplete Glgrep exe fugitive#GrepCommand(0, <count> > 0 ? <count> : 0, +"<range>", <bang>0, "<mods>", <q-args>)'
                            
    1              0.000012 exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete Gclog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "c")'
    1              0.000012 exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete GcLog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "c")'
    1              0.000013 exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete Gllog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "l")'
    1              0.000012 exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete GlLog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "l")'
                            
    1              0.000008 exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Ge       exe fugitive#Open("edit<bang>", 0, "<mods>", <q-args>)'
    1              0.000008 exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Gedit    exe fugitive#Open("edit<bang>", 0, "<mods>", <q-args>)'
    1              0.000008 exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Gpedit   exe fugitive#Open("pedit", <bang>0, "<mods>", <q-args>)'
    1              0.000016 exe 'command! -bar -bang -nargs=* -range=-1' s:addr_other '-complete=customlist,fugitive#EditComplete   Gsplit   exe fugitive#Open((<count> > 0 ? <count> : "").(<count> ? "split" : "edit"), <bang>0, "<mods>", <q-args>)'
    1              0.000018 exe 'command! -bar -bang -nargs=* -range=-1' s:addr_other '-complete=customlist,fugitive#EditComplete   Gvsplit  exe fugitive#Open((<count> > 0 ? <count> : "").(<count> ? "vsplit" : "edit!"), <bang>0, "<mods>", <q-args>)'
    1              0.000013 exe 'command! -bar -bang -nargs=* -range=-1' s:addr_tabs  '-complete=customlist,fugitive#EditComplete   Gtabedit exe fugitive#Open((<count> >= 0 ? <count> : "")."tabedit", <bang>0, "<mods>", <q-args>)'
    1              0.000013 exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Gdrop    exe fugitive#DropCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                            
    1              0.000004 if exists(':Gr') != 2
    1              0.000013   exe 'command! -bar -bang -nargs=* -range=-1                -complete=customlist,fugitive#ReadComplete   Gr     exe fugitive#ReadCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000001 endif
    1              0.000012 exe 'command! -bar -bang -nargs=* -range=-1                -complete=customlist,fugitive#ReadComplete   Gread    exe fugitive#ReadCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                            
    1              0.000009 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gdiffsplit  exe fugitive#Diffsplit(1, <bang>0, "<mods>", <q-args>)'
    1              0.000009 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Ghdiffsplit exe fugitive#Diffsplit(0, <bang>0, "<mods>", <q-args>)'
    1              0.000008 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gvdiffsplit exe fugitive#Diffsplit(0, <bang>0, "vertical <mods>", <q-args>)'
                            
    1              0.000012 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gw     exe fugitive#WriteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000012 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gwrite exe fugitive#WriteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000012 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gwq    exe fugitive#WqCommand(   <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                            
    1              0.000011 exe 'command! -bar -bang -nargs=0 GRemove exe fugitive#RemoveCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000015 exe 'command! -bar -bang -nargs=0 GUnlink exe fugitive#UnlinkCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000014 exe 'command! -bar -bang -nargs=0 GDelete exe fugitive#DeleteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000012 exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#CompleteObject GMove   exe fugitive#MoveCommand(  <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000012 exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#RenameComplete GRename exe fugitive#RenameCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000005 if exists(':Gremove') != 2 && get(g:, 'fugitive_legacy_commands', 0)
                              exe 'command! -bar -bang -nargs=0 Gremove exe fugitive#RemoveCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                                    \ '|echohl WarningMSG|echomsg ":Gremove is deprecated in favor of :GRemove"|echohl NONE'
    1              0.000005 elseif exists(':Gremove') != 2 && !exists('g:fugitive_legacy_commands')
    1              0.000006   exe 'command! -bar -bang -nargs=0 Gremove echoerr ":Gremove has been removed in favor of :GRemove"'
    1              0.000001 endif
    1              0.000004 if exists(':Gdelete') != 2 && get(g:, 'fugitive_legacy_commands', 0)
                              exe 'command! -bar -bang -nargs=0 Gdelete exe fugitive#DeleteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                                    \ '|echohl WarningMSG|echomsg ":Gdelete is deprecated in favor of :GDelete"|echohl NONE'
    1              0.000004 elseif exists(':Gdelete') != 2 && !exists('g:fugitive_legacy_commands')
    1              0.000006   exe 'command! -bar -bang -nargs=0 Gdelete echoerr ":Gdelete has been removed in favor of :GDelete"'
    1              0.000001 endif
    1              0.000004 if exists(':Gmove') != 2 && get(g:, 'fugitive_legacy_commands', 0)
                              exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#CompleteObject Gmove   exe fugitive#MoveCommand(  <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                                    \ '|echohl WarningMSG|echomsg ":Gmove is deprecated in favor of :GMove"|echohl NONE'
    1              0.000004 elseif exists(':Gmove') != 2 && !exists('g:fugitive_legacy_commands')
    1              0.000008   exe 'command! -bar -bang -nargs=? -complete=customlist,fugitive#CompleteObject Gmove'
                                    \ 'echoerr ":Gmove has been removed in favor of :GMove"'
    1              0.000001 endif
    1              0.000004 if exists(':Grename') != 2 && get(g:, 'fugitive_legacy_commands', 0)
                              exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#RenameComplete Grename exe fugitive#RenameCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                                    \ '|echohl WarningMSG|echomsg ":Grename is deprecated in favor of :GRename"|echohl NONE'
    1              0.000004 elseif exists(':Grename') != 2 && !exists('g:fugitive_legacy_commands')
    1              0.000008   exe 'command! -bar -bang -nargs=? -complete=customlist,fugitive#RenameComplete Grename'
                                    \ 'echoerr ":Grename has been removed in favor of :GRename"'
    1              0.000001 endif
                            
    1              0.000013 exe 'command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject GBrowse exe fugitive#BrowseCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000004 if exists(':Gbrowse') != 2 && get(g:, 'fugitive_legacy_commands', 0)
                              exe 'command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject Gbrowse exe fugitive#BrowseCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                                    \ '|if <bang>1|redraw!|endif|echohl WarningMSG|echomsg ":Gbrowse is deprecated in favor of :GBrowse"|echohl NONE'
    1              0.000004 elseif exists(':Gbrowse') != 2 && !exists('g:fugitive_legacy_commands')
    1              0.000008   exe 'command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject Gbrowse'
                                    \ 'echoerr ":Gbrowse has been removed in favor of :GBrowse"'
    1              0.000001 endif
                            
    1              0.000002 if v:version < 704
                              finish
    1              0.000001 endif
                            
    1              0.000038 let g:io_fugitive = {
                                  \ 'simplify': function('fugitive#simplify'),
                                  \ 'resolve': function('fugitive#resolve'),
                                  \ 'getftime': function('fugitive#getftime'),
                                  \ 'getfsize': function('fugitive#getfsize'),
                                  \ 'getftype': function('fugitive#getftype'),
                                  \ 'filereadable': function('fugitive#filereadable'),
                                  \ 'filewritable': function('fugitive#filewritable'),
                                  \ 'isdirectory': function('fugitive#isdirectory'),
                                  \ 'getfperm': function('fugitive#getfperm'),
                                  \ 'setfperm': function('fugitive#setfperm'),
                                  \ 'readfile': function('fugitive#readfile'),
                                  \ 'writefile': function('fugitive#writefile'),
                                  \ 'glob': function('fugitive#glob'),
                                  \ 'delete': function('fugitive#delete'),
                                  \ 'Real': function('FugitiveReal')}
                            
    1              0.000005 augroup fugitive
    1              0.000010   autocmd!
                            
    1              0.000012   autocmd BufNewFile,BufReadPost *
                                    \ if exists('b:git_dir') && b:git_dir =~# '^$\|' . s:bad_git_dir |
                                    \   unlet b:git_dir |
                                    \ endif
    1              0.000006   autocmd FileType           netrw
                                    \ if exists('b:git_dir') && b:git_dir =~# '^$\|' . s:bad_git_dir |
                                    \   unlet b:git_dir |
                                    \ endif
    1              0.000003   autocmd BufFilePost            *  unlet! b:git_dir
                            
    1              0.000004   autocmd FileType git
                                    \ call fugitive#MapCfile()
    1              0.000005   autocmd FileType gitcommit
                                    \ call fugitive#MapCfile('fugitive#MessageCfile()')
    1              0.000006   autocmd FileType git,gitcommit
                                    \ if &foldtext ==# 'foldtext()' |
                                    \    setlocal foldtext=fugitive#Foldtext() |
                                    \ endif
    1              0.000005   autocmd FileType fugitive
                                    \ call fugitive#MapCfile('fugitive#PorcelainCfile()')
    1              0.000007   autocmd FileType gitrebase
                                    \ let &l:include = '^\%(pick\|squash\|edit\|reword\|fixup\|drop\|[pserfd]\)\>' |
                                    \ if &l:includeexpr !~# 'Fugitive' |
                                    \   let &l:includeexpr = 'v:fname =~# ''^\x\{4,\}$'' && len(FugitiveGitDir()) ? FugitiveFind(v:fname) : ' .
                                    \     (len(&l:includeexpr) ? &l:includeexpr : 'v:fname') |
                                    \ endif |
                                    \ let b:undo_ftplugin = get(b:, 'undo_ftplugin', 'exe') . '|setl inex= inc='
                            
    1              0.000012   autocmd BufReadCmd index{,.lock} nested
                                    \ if FugitiveIsGitDir(expand('<amatch>:p:h')) |
                                    \   let b:git_dir = s:Slash(expand('<amatch>:p:h')) |
                                    \   exe fugitive#BufReadStatus(v:cmdbang) |
                                    \   echohl WarningMSG |
                                    \   echo "fugitive: Direct editing of .git/" . expand('%:t') . " is deprecated" |
                                    \   echohl NONE |
                                    \ elseif filereadable(expand('<amatch>')) |
                                    \   silent doautocmd BufReadPre |
                                    \   keepalt noautocmd read <amatch> |
                                    \   silent 1delete_ |
                                    \   silent doautocmd BufReadPost |
                                    \ else |
                                    \   silent doautocmd BufNewFile |
                                    \ endif
                            
    1              0.000006   autocmd BufReadCmd   fugitive://*          nested exe fugitive#BufReadCmd() |
                                    \ if &path =~# '^\.\%(,\|$\)' |
                                    \   let &l:path = substitute(&path, '^\.,\=', '', '') |
                                    \ endif
    1              0.000005   autocmd BufWriteCmd  fugitive://*          nested exe fugitive#BufWriteCmd()
    1              0.000005   autocmd FileReadCmd  fugitive://*          nested exe fugitive#FileReadCmd()
    1              0.000004   autocmd FileWriteCmd fugitive://*          nested exe fugitive#FileWriteCmd()
    1              0.000003   if exists('##SourceCmd')
    1              0.000004     autocmd SourceCmd     fugitive://*       nested exe fugitive#SourceCmd()
    1              0.000001   endif
                            
    1              0.000004   autocmd User Flags call Hoist('buffer', function('FugitiveStatusline'))
                            
    1              0.000007   autocmd User ProjectionistDetect call s:ProjectionistDetect()
    1              0.000001 augroup END
                            
    1              0.000019 nmap <script><silent> <Plug>fugitive:y<C-G> :<C-U>call setreg(v:register, fugitive#Object(@%))<CR>
    1              0.000005 nmap <script> <Plug>fugitive: <Nop>
                            
    1              0.000003 if get(g:, 'fugitive_no_maps')
                              finish
    1              0.000001 endif
                            
    1              0.000003 function! s:Map(mode, lhs, rhs, flags) abort
                              let flags = a:flags . (a:rhs =~# '<Plug>' ? '' : '<script>') . '<nowait>'
                              let head = a:lhs
                              let tail = ''
                              let keys = get(g:, a:mode.'remap', {})
                              if len(keys) && type(keys) == type({})
                                while !empty(head)
                                  if has_key(keys, head)
                                    let head = keys[head]
                                    if empty(head)
                                      return
                                    endif
                                    break
                                  endif
                                  let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
                                  let head = substitute(head, '<[^<>]*>$\|.$', '', '')
                                endwhile
                              endif
                              if empty(mapcheck(head.tail, a:mode))
                                exe a:mode.'map' flags head.tail a:rhs
                              endif
                            endfunction
                            
    1   0.000089   0.000017 call s:Map('c', '<C-R><C-G>', 'fnameescape(fugitive#Object(@%))', '<expr>')
    1   0.000067   0.000011 call s:Map('n', 'y<C-G>', ':<C-U>call setreg(v:register, fugitive#Object(@%))<CR>', '<silent>')

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/vim-illuminate/plugin/illuminate.vim
Sourced 1 time
Total time:   0.002359
 Self time:   0.002359

count  total (s)   self (s)
                            " illuminate.vim - Vim plugin for selectively illuminating other uses of current word
                            " Maintainer:	Adam P. Regasz-Rethy (RRethy) <rethy.spud@gmail.com>
                            " Version: 2.0
                            
    1              0.000004 if exists('g:loaded_illuminate')
                              finish
    1              0.000001 endif
                            
    1              0.000003 let g:loaded_illuminate = 1
                            
    1              0.000007 if has('nvim-0.7.2') && get(g:, 'Illuminate_useDeprecated', 0) != 1
    1              0.000001 lua << EOF
                                local ok, ts = pcall(require, 'nvim-treesitter')
                                if ok then
                                    ts.define_modules({
                                        illuminate = {
                                            module_path = 'illuminate.providers.treesitter',
                                            enable = true,
                                            disable = {},
                                            is_supported = require('nvim-treesitter.query').has_locals,
                                        }
                                    })
                                end
                                require('illuminate.engine').start()
                                vim.api.nvim_create_user_command('IlluminatePause', require('illuminate').pause, { bang = true })
                                vim.api.nvim_create_user_command('IlluminateResume', require('illuminate').resume, { bang = true })
                                vim.api.nvim_create_user_command('IlluminateToggle', require('illuminate').toggle, { bang = true })
                                vim.api.nvim_create_user_command('IlluminatePauseBuf', require('illuminate').pause_buf, { bang = true })
                                vim.api.nvim_create_user_command('IlluminateResumeBuf', require('illuminate').resume_buf, { bang = true })
                                vim.api.nvim_create_user_command('IlluminateToggleBuf', require('illuminate').toggle_buf, { bang = true })
                                vim.api.nvim_create_user_command('IlluminateDebug', require('illuminate').debug, { bang = true })
                            
                                if not require('illuminate.util').has_keymap('n', '<a-n>') then
                                    vim.keymap.set('n', '<a-n>', require('illuminate').goto_next_reference, { desc = "Move to next reference" })
                                end
                                if not require('illuminate.util').has_keymap('n', '<a-p>') then
                                    vim.keymap.set('n', '<a-p>', require('illuminate').goto_prev_reference, { desc = "Move to previous reference" })
                                end
                                if not require('illuminate.util').has_keymap('o', '<a-i>') then
                                    vim.keymap.set('o', '<a-i>', require('illuminate').textobj_select)
                                end
                                if not require('illuminate.util').has_keymap('x', '<a-i>') then
                                    vim.keymap.set('x', '<a-i>', require('illuminate').textobj_select)
                                end
                            EOF
                            
    1              0.000049 lua require('illuminate').set_highlight_defaults()
    1              0.000005 augroup vim_illuminate_autocmds
    1              0.000011     autocmd!
    1              0.000007     autocmd ColorScheme * lua require('illuminate').set_highlight_defaults()
    1              0.000001 augroup END
                            
    1              0.000003 finish
                            end
                            
                            " Highlight group(s) {{{
                            if !hlexists('illuminatedWord')
                              " this is for backwards compatibility
                              if !empty(get(g:, 'Illuminate_hl_link', ''))
                                exe get(g:, 'Illuminate_hl_link', '')
                              else
                                hi def link illuminatedWord cursorline
                              endif
                            endif
                            " }}}
                            
                            " Autocommands {{{
                            if has('autocmd')
                              augroup illuminated_autocmd
                                autocmd!
                                autocmd CursorMoved,InsertLeave * call illuminate#on_cursor_moved()
                                autocmd WinLeave,BufLeave * call illuminate#on_leaving_autocmds()
                                autocmd CursorMovedI * call illuminate#on_cursor_moved_i()
                                autocmd InsertEnter * call illuminate#on_insert_entered()
                              augroup END
                            else
                              echoerr 'Illuminate requires Vim compiled with +autocmd'
                              finish
                            endif
                            " }}}
                            
                            " Commands {{{
                            command! -nargs=0 -bang IlluminationDisable call illuminate#disable_illumination(<bang>0)
                            command! -nargs=0 -bang IlluminationEnable call illuminate#enable_illumination(<bang>0)
                            command! -nargs=0 -bang IlluminationToggle call illuminate#toggle_illumination(<bang>0)
                            " }}} Commands:
                            
                            " vim: foldlevel=1 foldmethod=marker

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/cmp-buffer/after/plugin/cmp_buffer.lua
Sourced 1 time
Total time:   0.000641
 Self time:   0.000641

count  total (s)   self (s)
                            require('cmp').register_source('buffer', require('cmp_buffer'))

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/cmp-cmdline/after/plugin/cmp_cmdline.lua
Sourced 1 time
Total time:   0.000358
 Self time:   0.000358

count  total (s)   self (s)
                            require('cmp').register_source('cmdline', require('cmp_cmdline').new())

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/cmp-nvim-lsp/after/plugin/cmp_nvim_lsp.lua
Sourced 1 time
Total time:   0.000383
 Self time:   0.000383

count  total (s)   self (s)
                            require('cmp_nvim_lsp').setup()

SCRIPT  /home/benk/.local/share/nvim/site/pack/packer/start/cmp-path/after/plugin/cmp_path.lua
Sourced 1 time
Total time:   0.000464
 Self time:   0.000464

count  total (s)   self (s)
                            require('cmp').register_source('path', require('cmp_path').new())

FUNCTION  <SNR>38_CreateMaps()
    Defined: ~/.local/share/nvim/site/pack/packer/start/nerdcommenter/plugin/nerdcommenter.vim:52
Called 18 times
Total time:   0.001856
 Self time:   0.001856

count  total (s)   self (s)
                                " Build up a map command like
                                " 'noremap <silent> <Plug>NERDCommenterComment :call nerdcommenter#Comment("n", "Comment")'
   18              0.000040     let plug = '<Plug>NERDCommenter' . a:target
   18              0.000044     let plug_start = 'noremap <silent> ' . plug . ' :call nerdcommenter#Comment("'
   18              0.000034     let plug_end = '", "' . a:target . '")<CR>'
                                " Build up a menu command like
                                " 'menu <silent> comment.Comment<Tab>\\cc <Plug>NERDCommenterComment'
   18              0.000092     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment', '&Plugin.Nerd\ &Commenter'], g:NERDMenuMode, '')
   18              0.000068     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')
   18              0.000027     if strlen(a:combo)
   13              0.000037         let leader = exists('g:mapleader') ? g:mapleader : '\'
   13              0.000045         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo
   18              0.000010     endif
   18              0.000057     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)
                                " Execute the commands built above for each requested mode.
   46              0.000133     for mode in (a:modes ==# '') ? [''] : split(a:modes, '\zs')
   28              0.000045         if strlen(a:combo)
   23              0.000213             execute mode . plug_start . mode . plug_end
   23              0.000188             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)
   23              0.000177                 execute mode . 'map <leader>' . a:combo . ' ' . plug
   23              0.000012             endif
   28              0.000013         endif
                                    " Check if the user wants the menu to be displayed.
   28              0.000032         if g:NERDMenuMode !=# 0
   28              0.000262             execute mode . menu_command
   28              0.000017         endif
   46              0.000036     endfor

FUNCTION  <SNR>21_LocalBrowse()
    Defined: /usr/share/nvim/runtime/plugin/netrwPlugin.vim:102
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
    1              0.000003   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
    1              0.000001    return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
                              if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               " Jul 13, 2021: for whatever reason, preceding the following call with
                               " a   sil!  causes an unbalanced if-endif vim error
                               call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
                              endif
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  <SNR>22_GetManifestPath()
    Defined: /usr/share/nvim/runtime/plugin/rplugin.vim:7
Called 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000002   let manifest_base = ''
                            
    1              0.000004   if exists('$NVIM_RPLUGIN_MANIFEST')
                                return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
    1              0.000001   endif
                            
    1              0.000005   let dest = stdpath('data')
    1              0.000003   if !empty(dest)
    1              0.000005     if !isdirectory(dest)
                                  call mkdir(dest, 'p', 0700)
    1              0.000001     endif
    1              0.000002     let manifest_base = dest
    1              0.000001   endif
                            
    1              0.000003   return manifest_base.'/rplugin.vim'

FUNCTION  <SNR>52_Map()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-fugitive/plugin/fugitive.vim:727
Called 2 times
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)
    2              0.000015   let flags = a:flags . (a:rhs =~# '<Plug>' ? '' : '<script>') . '<nowait>'
    2              0.000004   let head = a:lhs
    2              0.000002   let tail = ''
    2              0.000008   let keys = get(g:, a:mode.'remap', {})
    2              0.000007   if len(keys) && type(keys) == type({})
                                while !empty(head)
                                  if has_key(keys, head)
                                    let head = keys[head]
                                    if empty(head)
                                      return
                                    endif
                                    break
                                  endif
                                  let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
                                  let head = substitute(head, '<[^<>]*>$\|.$', '', '')
                                endwhile
    2              0.000001   endif
    2              0.000033   if empty(mapcheck(head.tail, a:mode))
    2              0.000021     exe a:mode.'map' flags head.tail a:rhs
    2              0.000001   endif

FUNCTION  <SNR>22_LoadRemotePlugins()
    Defined: /usr/share/nvim/runtime/plugin/rplugin.vim:56
Called 1 time
Total time:   0.000133
 Self time:   0.000050

count  total (s)   self (s)
    1   0.000076   0.000008   let g:loaded_remote_plugins = s:GetManifest()
    1              0.000006   if filereadable(g:loaded_remote_plugins)
    1   0.000049   0.000034     execute 'source' fnameescape(g:loaded_remote_plugins)
    1              0.000001   endif

FUNCTION  <SNR>38_InitVariable()
    Defined: ~/.local/share/nvim/site/pack/packer/start/nerdcommenter/plugin/nerdcommenter.vim:20
Called 19 times
Total time:   0.000147
 Self time:   0.000147

count  total (s)   self (s)
   19              0.000040     if !exists(a:var)
   19              0.000088         execute 'let ' . a:var . ' = ' . string(a:value)
   19              0.000010     endif

FUNCTION  <SNR>15_SynSet()
    Defined: /usr/share/nvim/runtime/syntax/synload.vim:26
Called 2 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    2              0.000006   syn clear
    2              0.000005   if exists("b:current_syntax")
                                unlet b:current_syntax
    2              0.000001   endif
                            
    2              0.000007   0verbose let s = expand("<amatch>")
    2              0.000004   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    2              0.000003   elseif s == "OFF"
                                let s = ""
    2              0.000001   endif
                            
    2              0.000002   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
                                for name in split(s, '\.')
                                  if !empty(name)
                                    exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
                                    exe "runtime! syntax/" . name . ".lua syntax/" . name . "/*.lua"
                                  endif
                                endfor
    2              0.000001   endif

FUNCTION  <SNR>22_GetManifest()
    Defined: /usr/share/nvim/runtime/plugin/rplugin.vim:42
Called 1 time
Total time:   0.000067
 Self time:   0.000032

count  total (s)   self (s)
    1   0.000045   0.000009   let manifest = s:GetManifestPath()
    1              0.000008   if !filereadable(manifest)
                                " Check if an old manifest file exists and move it to the new location.
                                for old_manifest in s:GetOldManifestPaths()
                                  if filereadable(old_manifest)
                                    call rename(old_manifest, manifest)
                                    break
                                  endif
                                endfor
    1              0.000001   endif
    1              0.000001   return manifest

FUNCTION  <SNR>35_try()
    Defined: ~/.local/share/nvim/site/pack/packer/start/indent-blankline.nvim/plugin/indent_blankline.vim:7
Called 1 time
Total time:   0.000609
 Self time:   0.000609

count  total (s)   self (s)
    1              0.000002     try
    1              0.000599         execute a:cmd
                                catch /E12/
                                    return
    1              0.000002     endtry

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   18   0.001856             <SNR>38_CreateMaps()
    1   0.000609             <SNR>35_try()
   19   0.000147             <SNR>38_InitVariable()
    1   0.000133   0.000050  <SNR>22_LoadRemotePlugins()
    2   0.000129             <SNR>52_Map()
    2   0.000073             <SNR>15_SynSet()
    1   0.000067   0.000032  <SNR>22_GetManifest()
    1   0.000035             <SNR>22_GetManifestPath()
    1   0.000010             <SNR>21_LocalBrowse()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   18              0.001856  <SNR>38_CreateMaps()
    1              0.000609  <SNR>35_try()
   19              0.000147  <SNR>38_InitVariable()
    2              0.000129  <SNR>52_Map()
    2              0.000073  <SNR>15_SynSet()
    1   0.000133   0.000050  <SNR>22_LoadRemotePlugins()
    1              0.000035  <SNR>22_GetManifestPath()
    1   0.000067   0.000032  <SNR>22_GetManifest()
    1              0.000010  <SNR>21_LocalBrowse()

